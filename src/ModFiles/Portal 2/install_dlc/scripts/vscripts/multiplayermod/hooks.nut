//---------------------------------------------------
//         *****!Do not edit this file!*****
//---------------------------------------------------
// Purpose: Manages the different events and what
// happens right before mapsupport code is called.
//---------------------------------------------------

// This function is how communication is made with all mapsupport files.
// In case no mapsupport file exists, it will fall back to this (nothing) instead of an error
function MapSupport(
MSInstantRun,       // 1. Runs 0.02 after host client loads in the current map      (Returns true)
MSLoop,             // 2. Looped every 0.1 second in case of changes in the server  (Returns true)
MSPostPlayerSpawn,  // 3. Runs once the game begins (players can now move)          (Returns true)
MSPostMapSpawn,     // 4. Runs after the host loads in                              (Returns true)
MSOnPlayerJoin,     // 5. Runs when a player enters the server                      (Returns true)
MSOnDeath,          // 6. Runs on player death                                      (Player handle is provided)
MSOnRespawn,        // 7. Runs on player respawn                                    (Player handle is provided)
) {}

// 1
function InstantRun() {
    // Make sure that Config_DevMode and `developer` stays enabled when either Config_VScriptDebug is enabled
    if (Config_VScriptDebug) {
        Config_DevMode = true
        EntFire("p2mm_servercommand", "command", "developer 1")
    } else {
        Config_DevMode = false
        EntFire("p2mm_servercommand", "command", "developer 0")
    }

    // Trigger map-specific code
    MapSupport(true, false, false, false, false, false, false)

    // Tell the plugin that P2MMLoop can now be called
    EntFire("p2mm_servercommand", "command", "p2mm_loop 1", 0.01)

    // Delay the creation of our map-specific entities before so an engine error from the entity limit doesn't occur
    EntFire("p2mm_servercommand", "command", "script CreateOurEntities()", 0.05)

    if (g_bIsCommunityCoopHub) {
        PostPlayerSpawn()
        if (!g_bCheatsOn) {
            if (IsDedicatedServer()) {
                EntFire("p2mm_servercommand", "command", "sv_cheats 0")
            } else {
                EntFire("p2mm_servercommand", "command", "hud_saytext_time 0; sv_cheats 0; hud_saytext_time 12")
            }
        }
        Player2Joined = true
    }

    // For adding a output to the disassembler's trigger_playerteams trigger so the disassembler's disassembly animation is colored the players color
    if (!g_bIsOnSingleplayerMaps) {
        for (local disassemblerTrigger = null; disassemblerTrigger = Entities.FindByClassname(disassemblerTrigger, "trigger_playerteam");) {
            if (disassemblerTrigger.GetName().find("trigger_exit_lift") != null) {
                EntFireByHandle(disassemblerTrigger, "AddOutput", "OnStartTouch !activator:RunScriptCode:ColorDisassemblerAnimation(activator):0:-1", 0, null, null)
            }
        }
    }

    if (!Config_EnablePinging) {
        EntFireByHandle(Entities.FindByName(null, "p2mm_env_global01"), "turnon", "", delay, null, null)
        EntFireByHandle(Entities.FindByName(null, "p2mm_env_global02"), "turnon", "", delay, null, null)
    }
    if (!Config_EnableEmoting) {    
        EntFireByHandle(Entities.FindByName(null, "p2mm_env_global03"), "turnon", "", delay, null, null)
        EntFireByHandle(Entities.FindByName(null, "p2mm_env_global04"), "turnon", "", delay, null, null)
    }
}

// 2
function P2MMLoop() {
    // Trigger map-specific code
    MapSupport(false, true, false, false, false, false, false)

    // Get all players and check for changes
    for (local p = null; p = Entities.FindByClassname(p, "player");) {
        if (!p.ValidateScriptScope()) { continue }
        
        // Update everyone's class if PermaPotato is on
        FindPlayerClass(p).potatogun = PermaPotato

        //## PotatoIfy loop ##//
        if (PermaPotato) {
            PotatoIfy(p, "1")
        } else {
            PotatoIfy(p, "0")
        }

        //## Set PlayerModel ##//
        if (FindPlayerClass(p) != null) {
            if (FindPlayerClass(p).playermodel != null) {
                if (FindPlayerClass(p).playermodel != p.GetModelName()) {
                    EntFire("p2mm_servercommand", "command", "script Entities.FindByName(null, \"" + p.GetName() + "\").SetModel(\"" + FindPlayerClass(p).playermodel + "\")", 1)
                }
            }
        }
    }

    //## Update Portal Gun names ##//
    for (local p = null; p = Entities.FindByClassname(p, "weapon_portalgun");) {
        // if it doesn't have a name yet
        if (p.GetName() == "") {
            // Set The Name Of The Portalgun (based on PLAYER index)
            p.__KeyValueFromString("targetname", "weapon_portalgun_player" + p.GetRootMoveParent().entindex())
        }
    }

    // //## Nametags ##//
    if (Config_UseNametags && g_bAllowNametags) {
        if (Time() - PreviousNametagItter > 0.1) {
            PreviousNametagItter = Time()
            for (local p = null; p = Entities.FindByClassname(p, "player");) {
                if (FindPlayerClass(p) != null) {

                    // Get number of players in the game
                    local playernums = CalcNumPlayers()

                    local checkcount = 1
                    // Optimise search based on player count
                    if (playernums <= 6) {
                        checkcount = playernums
                    } else if (playernums <= 11) {
                        checkcount = 6
                    } else if (playernums <= 14) {
                        checkcount = 4
                    } else if (playernums <= 17) {
                        checkcount = 3
                    } else if (playernums <= 21) {
                        checkcount = 2
                    } else if (playernums <= 33) {
                        checkcount = 1
                    }
                    local eyeplayer = ForwardVectorTraceLine(p.EyePosition(), FindPlayerClass(p).eyeforwardvector, 0, 10000, checkcount, 1, 32, p, "player")
                    if (eyeplayer != null) {
                        local clr = FindPlayerClass(eyeplayer).color
                        EntFireByHandle(nametagdisplay, "settextcolor", clr.r + " " + clr.g + " " + clr.b, 0, p, p)
                        EntFireByHandle(nametagdisplay, "settext", FindPlayerClass(eyeplayer).username, 0, p, p)
                        EntFireByHandle(nametagdisplay, "Display", "", 0, p, p)
                    }
                }
            }
        }
    }

    //## Update eye angles ##//
    if (Config_UseNametags && g_bAllowNametags) {
        if (!g_bCoordsAlternate) {
            // Alternate so our timings space out correctly
            if (LastCoordGetPlayer != null) {
                LastCoordGetPlayer = Entities.FindByClassname(LastCoordGetPlayer, "player")
            } else {
                LastCoordGetPlayer = Entities.FindByClassname(null, "player")
            }
            if (LastCoordGetPlayer != null) {
                EntFireByHandle(measuremovement_eyeposition, "SetMeasureTarget", LastCoordGetPlayer.GetName(), 0.0, null, null)
                // Alternate so our timings space out correctly
                g_bCoordsAlternate = true
            }
        } else {
            if (LastCoordGetPlayer != null && Entities.FindByName(null, "p2mm_logic_measure_movement_eyeposition")) {
                local currentplayerclass = FindPlayerClass(LastCoordGetPlayer)
                if (currentplayerclass != null) {
                    if (OriginalAngle == null && g_bCanCheckAngle) {
                        OriginalAngle = measuremovement_eyeposition.GetAngles()
                        Entities.FindByClassname(null, "player").SetAngles(OriginalAngle.x + 7.0, OriginalAngle.y + 4.7, OriginalAngle.z + 7.1)
                    }

                    currentplayerclass.eyeangles = measuremovement_eyeposition.GetAngles()
                    currentplayerclass.eyeforwardvector = measuremovement_eyeposition.GetForwardVector()
                }
            }
            // Alternate so our timings space out correctly
            g_bCoordsAlternate = false
        }
    } else {
        for (local p = null; p = Entities.FindByClassname(p, "player");) {
            FindPlayerClass(p).eyeangles = Vector(0, 0, 0)
            FindPlayerClass(p).eyeforwardvector = Vector(0, 0, 0)
        }
    }

    // // ENTITY OPTIMIZATION / DELETION ///////////////
    // local cnt = GetEntityCount()
    // local amtpast = cnt - (EntityCap - EntityCapLeeway) // this is the amount of entities we have past the caps leeway amount
    // local amtdeleted = 0

    // if (cnt > EntityCap - EntityCapLeeway) {
    //     if (cnt >= FailsafeEntityCap) {
    //         printl("CRASH AND BURN!!!!: ENTITY COUNT HAS EXCEEDED THE ABSOLUTE MAXIMUM OF " + FailsafeEntityCap + "!  EXITING TO HUB TO PREVENT CRASH!")
    //         EntFire("p2mm_servercommand", "command", "changelevel mp_coop_lobby_3")
    //     }
    //     printl("LEEWAY EXCEEDED (AMOUNT: " + amtpast + ") CAP: " + EntityCap + " LEEWAY: " + EntityCapLeeway + " ENTITY COUNT: " + cnt + "AMT DELETED: " + amtdeleted)
    //     foreach (entclass in ExpendableEntities) {

    //         local curdelamt = amtpast - amtdeleted
    //         if (amtdeleted < amtpast) { // if we are still over the cap

    //             local amt = GetEntityCount(entclass)
    //             printl("CURRENT AMOUNT OF " + entclass + ": " + amt)

    //             if (amt > 0) {
    //                 if (amt >= curdelamt) {
    //                     DeleteAmountOfEntities(entclass, curdelamt)
    //                     return
    //                 } else {
    //                     DeleteAmountOfEntities(entclass, amt)
    //                     amtdeleted = amtdeleted + amt
    //                 }
    //             }


    //         } else {
    //             return
    //         }
    //     }
    // }

    /////////////////////////////////////////////////


    //## Cache original spawn position ##//
    if (cacheoriginalplayerposition == 0 && Entities.FindByClassname(null, "player") && !g_bIsCommunityCoopHub) {
        // OldPlayerPos = the blues inital spawn position
        try {
            OldPlayerPos = Entities.FindByName(null, "blue").GetOrigin()
            OldPlayerAngles = Entities.FindByName(null, "blue").GetAngles()
        } catch (exception) {
            try {
                OldPlayerPos = Entities.FindByName(null, "info_coop_spawn").GetOrigin()
                OldPlayerAngles = Entities.FindByName(null, "info_coop_spawn").GetAngles()
            } catch (exception) {
                    try {
                        OldPlayerPos = Entities.FindByName(null, "info_player_start").GetOrigin()
                        OldPlayerAngles = Entities.FindByName(null, "info_player_start").GetAngles()
                    } catch(exception) {
                        OldPlayerPos = Vector(0, 0, 0)
                        OldPlayerAngles = Vector(0, 0, 0)
                        printlP2MM(1, true, "Error: Could not cache player position. This is catastrophic!")
                        cacheoriginalplayerposition = 1
                    }
                }
            }
        cacheoriginalplayerposition = 1
    }

    //## Hook first spawn ##//
    if (PostMapSpawnDone && !g_bIsCommunityCoopHub) {
        if (!g_bDoneWaiting) {
            if (g_bCanHook) {
                if (Entities.FindByClassname(null, "player").GetHealth() < 200003001 || Entities.FindByClassname(null, "player").GetHealth() > 230053963) {
                    g_bDoneWaiting = true
                    PostPlayerSpawn()
                    if (GetDeveloperLevelP2MM()) {
                        printl("=================================HEALTH SPAWN")
                    }
                }
            }
            EntFire("p2mm_wait_for_players_text", "Display")
        }
    }

    //## GlobalSpawnClass SetSpawn ##//
    if (GlobalSpawnClass.m_bUseSetSpawn) {
        for (local p = null; p = Entities.FindByClassnameWithin(p, "player", GlobalSpawnClass.m_cSetSpawn.position, GlobalSpawnClass.m_cSetSpawn.radius);) {
            TeleportToSpawnPoint(p, null)
        }
    }

    //## Run all custom generated props / prop related Garry's Mod code ##//
    CreatePropsForLevel(false, false)


    //## Config developer mode loop ##//
    if (Config_DevMode) {
        // Change Config_DevMode variable based on convar "developer"
        if (!GetDeveloperLevelP2MM()) {
            if (StartDevModeCheck) {
                Config_DevMode = false
            }
        } else {
            Config_DevMode = true
        }
    }
    
    // Random Turret and Frankenturret colors and models, but looped!
    if (Config_RandomTurretLoop && g_bHasSpawned) {
        for (local turret = null; turret = Entities.FindByClassname(turret, "npc_portal_turret_floor");) {
            local modelnumber = RandomInt(0, 2)
            if (modelnumber == 2) {
                modelnumber = 4
            }
            turret.__KeyValueFromInt("ModelIndex", modelnumber)
            local model = RandomInt(0, 2)

            if (model == 1) {
                turret.SetModel("models/npcs/turret/turret_skeleton.mdl")
            } else if (model == 2) {
                turret.SetModel("models/npcs/turret/turret_backwards.mdl")
            }

            local randTurretColor = RandomColor()
            local r = randTurretColor.r
            local g = randTurretColor.g
            local b = randTurretColor.b

            EntFireByHandle(turret, "Color", (r + " " + g + " " + b), 0, null, null)
        }
        for (local frank = null; frank = Entities.FindByClassname(frank, "prop_monster_box");) {
            local randFrankColor = RandomColor()
            local r = randFrankColor.r
            local g = randFrankColor.g
            local b = randFrankColor.b

            EntFireByHandle(frank, "Color", (r + " " + g + " " + b), 0, null, null)
        }
    }
    

    //////////////////////////
    // RUNS EVERY 5 SECONDS //
    //////////////////////////

    if (Time() >= PreviousTime5Sec + 5) {
        PreviousTime5Sec = Time()

        // Color indicator
        if (Config_UseColorIndicator && g_bAllowColorIndicator && g_bHasSpawned) {
            for (local p = null; p = Entities.FindByClassname(p, "player");) {
                DisplayPlayerColor(p)
            }
        }
    }

    ///////////////////////
    // RUNS EVERY SECOND //
    ///////////////////////

    if (Time() >= PreviousTime1Sec + 1) {
        PreviousTime1Sec = Time()

        // Random portal sizes
        if (Config_RandomPortalSize) {
            randomportalsize = RandomInt(1, 100).tostring()
            randomportalsizeh = RandomInt(1, 100).tostring()

            try {
                for (local p = null; p = Entities.FindByClassname(p, "prop_portal");) {
                    p.__KeyValueFromString("HalfWidth", randomportalsize)
                    p.__KeyValueFromString("HalfHeight", randomportalsizeh)
                }
            } catch (exception) {}
        }

        //## Detect respawn ##//
        for (local p = null; p = Entities.FindByClassname(p, "player");) {
            if (p.GetHealth() >= 1) {
                // Get the players from the dead players array
                foreach (index, player in CurrentlyDead) {
                    if (player == p) {
                        CurrentlyDead.remove(index)
                        OnRespawn(p)
                    }
                }
            }
        }

        //## Singleplayer check that must be looped in case sv_cheats was changed ##//
        if (SetPhysTypeConvarLoaded) {
            if (g_bOverridePluginGrabController && g_bIsOnSingleplayerMaps) {
                SetPhysTypeConvar(0) // enable real-time physics
            } else {
                SetPhysTypeConvar(-1) // enable viewmodel physics, in case of changes. MP Gamerules already defaults to this without plugin
            }
        }

        //## Vote CC Timer Force End ##//
        if (Config_UseChatCommands && PluginLoaded) {
            // Display Text Status
            if (ShouldDisplayVoteText) {
                EntFire("VoteCounter", "Display")
                EntFire("VoteTimer", "Display")
                if (!ReversedTimer) {
                    // Revese the timer and firing time...
                    for (local i = 0; i <= VotingTime; i++) {
                        // TODO: AddOutput likes to replace ":" with "," in strings...
                        // ALSO when starting new votes if someone canceled or forcefully
                        // failed the previous one midway through, the text will appear to be 0
                        // Maybe use a logic_relay and CancelPending?
                        EntFire("VoteTimer", "AddOutput", "message Time: " + (VotingTime - i).tostring() + "s", i)
                    }
                    ReversedTimer = true
                }
            }
            // This also means that the vote is currently active, so
            // it is safe to assign new values to member variables
            if (bAllowVoteTimeCheck) {
                //## Update vote CC total players ##//
                VoteInstanceArray[0].UpdatePlayerCountText()
                if (Time() > VoteInitTime + VotingTime) {
                    bAllowVoteTimeCheck = false
                    local Vote = VoteInstanceArray[0]
                    if (Vote.iVotedYes > Vote.iCurrentNumberOfPlayers / 2) {
                        SendChatMessage("[VOTE] Majority of players have voted yes.", Vote.pVoteInitiator)
                        Vote.DoVote("succeed")
                    }
                    else if (Vote.iVotedNo > Vote.iCurrentNumberOfPlayers / 2) {
                        SendChatMessage("[VOTE] Majority of players have voted no.", Vote.pVoteInitiator)
                        Vote.DoVote("fail")
                    }
                    else if (Vote.iVotedYes == Vote.iVotedNo) {
                        // A message is already set for this
                        // SendChatMessage("[VOTE] Even number of voters on each side.", Vote.pVoteInitiator)
                        Vote.DoVote("fail")
                    } else {
                        SendChatMessage("[VOTE] Not enough players voted.", Vote.pVoteInitiator)
                        Vote.DoVote("fail")
                    }
                }
            }
        }
    }
}

// 3
function PostPlayerSpawn() {
    // Trigger map-specific code
    MapSupport(false, false, true, false, false, false, false)

    Player2Joined = true // in case no player joined yet and only the host spawned for now (LISTEN SERVER)

    EntFire("p2mm_servercommand", "command", "script ForceRespawnAll()", 1)

    if (!fogs) {
        usefogcontroller = false
        printlP2MM(1, true, "No fog controller found. Disabling fog controller...")
    } else {
        usefogcontroller = true
        printlP2MM(0, true, "Fog controller found. Enabling fog controller...")
    }

    if (usefogcontroller) {
        foreach (fog in fogs) {
            EntFireByHandle(Entities.FindByName(null, fog.name), "AddOutput", "OnTrigger p2mm_servercommand:command:script p2mmfogswitch(\"" + fog.fogname + "\")", 0, null, null)
        }

        defaultfog = fogs[0].fogname

        for (local p; p = Entities.FindByClassname(p, "player");) {
            EntFireByHandle(p, "setfogcontroller", defaultfog, 0, null, null)
        }
    }

    // Single player maps with chapter titles
    // Credit: Valve
    local CHAPTER_TITLES = [
        { map = "sp_a1_intro1", title_text = "#portal2_Chapter1_Title", subtitle_text = "#portal2_Chapter1_Subtitle", displayOnSpawn = false,		displaydelay = 1.0 },
        { map = "sp_a2_laser_intro", title_text = "#portal2_Chapter2_Title", subtitle_text = "#portal2_Chapter2_Subtitle", displayOnSpawn = true,	displaydelay = 2.5 },
        { map = "sp_a2_sphere_peek", title_text = "#portal2_Chapter3_Title", subtitle_text = "#portal2_Chapter3_Subtitle", displayOnSpawn = true,	displaydelay = 2.5 },
        { map = "sp_a2_column_blocker", title_text = "#portal2_Chapter4_Title", subtitle_text = "#portal2_Chapter4_Subtitle", displayOnSpawn = true, displaydelay = 2.5 },
        { map = "sp_a2_bts3", title_text = "#portal2_Chapter5_Title", subtitle_text = "#portal2_Chapter5_Subtitle", displayOnSpawn = true,			displaydelay = 1.0 },
        { map = "sp_a3_00", title_text = "#portal2_Chapter6_Title", subtitle_text = "#portal2_Chapter6_Subtitle", displayOnSpawn = true,			displaydelay = 1.5 },
        { map = "sp_a3_speed_ramp", title_text = "#portal2_Chapter7_Title", subtitle_text = "#portal2_Chapter7_Subtitle", displayOnSpawn = true,	displaydelay = 1.0 },
        { map = "sp_a4_intro", title_text = "#portal2_Chapter8_Title", subtitle_text = "#portal2_Chapter8_Subtitle", displayOnSpawn = true,			displaydelay = 2.5 },
        { map = "sp_a4_finale1", title_text = "#portal2_Chapter9_Title", subtitle_text = "#portal2_Chapter9_Subtitle", displayOnSpawn = false,		displaydelay = 1.0 },
    ]

    // Attempt to display chapter title
    // Credit: Valve
    foreach (index, level in CHAPTER_TITLES) {
		if (level.map == GetMapName() && level.displayOnSpawn ) {
            foreach (index, level in CHAPTER_TITLES) {
                if (level.map == GetMapName() ) {
                    EntFire( "@chapter_title_text", "SetTextColor", "210 210 210 128", 0.0 )
                    EntFire( "@chapter_title_text", "SetTextColor2", "50 90 116 128", 0.0 )
                    EntFire( "@chapter_title_text", "SetPosY", "0.32", 0.0 )
                    EntFire( "@chapter_title_text", "SetText", level.title_text, 0.0 )
                    EntFire( "@chapter_title_text", "Display", "", level.displaydelay )

                    EntFire( "@chapter_subtitle_text", "SetTextColor", "210 210 210 128", 0.0 )
                    EntFire( "@chapter_subtitle_text", "SetTextColor2", "50 90 116 128", 0.0 )
                    EntFire( "@chapter_subtitle_text", "SetPosY", "0.35", 0.0 )
                    EntFire( "@chapter_subtitle_text", "settext", level.subtitle_text, 0.0 )
                    EntFire( "@chapter_subtitle_text", "Display", "", level.displaydelay )
                }
            }
		}
	}

    // Set a variable to tell the map loaded
    g_bHasSpawned = true

    // Cache orange players original position
    try {
        if (Entities.FindByName(null, "red") != null && Entities.FindByName(null, "red").GetTeam() == TEAM_RED) {
            OrangeOldPlayerPos = p.GetOrigin()
        }
    } catch (exception) {}
    if (OrangeOldPlayerPos == null) {
        printlP2MM(1, true, "OrangeOldPlayerPos not set (Blue probably moved before Orange could load in) Setting OrangeOldPlayerPos to BlueOldPlayerPos")
        OrangeOldPlayerPos = OldPlayerPos
        OrangeCacheFailed = true
    }

    // Attempt to force open the map droppers for both blue and red
    local ForceOpenMapDroppers = function(PosVector, Radius, OverrideName) {
        if (OverrideName == "Red" && OrangeCacheFailed) {
            Radius = 350
        }
        try {
            for (local ent; ent = Entities.FindByClassnameWithin(ent, "prop_dynamic", Vector(PosVector.x, PosVector.y, PosVector.z-300), Radius);) {
                if (ent.GetModelName() == "models/props_underground/underground_boxdropper.mdl" || ent.GetModelName() == "models/props_backstage/item_dropper.mdl") {
                    EntFireByHandle(ent, "setanimation", "Open", 0, null, null)
                    if (ent.GetModelName() == "models/props_backstage/item_dropper.mdl") {
                        EntFireByHandle(ent, "setanimation", "item_dropper_open", 0, null, null)
                    }
                    // ent.__KeyValueFromString("targetname", OverrideName + "DropperForcedOpenP2MM") // Has no purpose right now
                }
            }
        } catch (exception) {
            printlP2MM(1, true, OverrideName + " dropper not found! Cannot force open dropper.")
        }
    }

    ForceOpenMapDroppers(OldPlayerPos, 100, "Blue")  // Force open the blue player droppers
    ForceOpenMapDroppers(OrangeOldPlayerPos, 150, "Red")  // Force open the red player droppers

    if (!g_bIsOnSingleplayerMaps) {
        //# Attempt to fix some general map issues #//
        local CoopDoorEntities = [
            "airlock_1-door1-airlock_entry_door_close_rl",
            "airlock_2-door1-airlock_entry_door_close_rl",
            "airlock_3-door1-airlock_entry_door_close_rl",  //mp_coop_sx_bounce (Sixense map)
            "airlock-door1-airlock_entry_door_close_rl",
            "airlock1-door1-door_close",
            "airlock_1-door1-door_close",
            "blue_door_1-airlock_player_block",
            "blue_door_1-ramp_close_start",
            "camera_door_3-relay_doorclose",
            "door1-airlock_entry_door_close_rl",
            "entry_airlock-door1-airlock_entry_door_close_rl",
            "last_airlock-door1-airlock_entry_door_close_rl",
            "orange_door_1-ramp_close_start",
            "orange_door_1-airlock_player_block"
        ]
        foreach (DoorType in CoopDoorEntities) {
            // Attempt to destroy them
            try {
                Entities.FindByName(null, DoorType).Destroy()
            } catch (exception) {}
        }
        local airlockrelays = [
            "airlock_1-red_dropper-relay_tube_open",
            "airlock_1-red_dropper-relay_tube_close",
            "InstanceAuto27-red_dropper-relay_tube_open",
            "InstanceAuto27-red_dropper-relay_tube_close",
            "InstanceAuto7-red_dropper-relay_tube_open",
            "InstanceAuto7-red_dropper-relay_tube_close",
            "InstanceAuto34-red_dropper-relay_tube_open",
            "InstanceAuto34-red_dropper-relay_tube_close",
            "InstanceAuto15-red_dropper-relay_tube_open",
            "InstanceAuto15-red_dropper-relay_tube_close"
        ]
        foreach (airlockrelay in airlockrelays) {
            // Try our best to enable fast retrigger to prevent error spam in console
            // (Does not take effect until after the dropper has closed at least once)
            try {
                Entities.FindByName(null, airlockrelay).__KeyValueFromString("spawnflags", "3")
            } catch (exception) {}
        }
    }

    // Create props after cache
    EntFire("p2mm_servercommand", "command", "script CreatePropsForLevel(false, true)")

    // Remove scoreboard
    //! BROKEN BY VALVE! ANY FIXES ARE APPRECIATED!
    // if (!IsLocalSplitScreen() && !IsDedicatedServer() && !g_bIsCommunityCoopHub /*&& !Player2Joined*/) {
    //     for (local ent; ent = Entities.FindByClassname(ent, "player");) {
    //         // TODO: Is there a better way to trigger this for the host player on a listen server?
    //         // Right now, this will enter -score for every player
    //         EntFireByHandle(p2mm_clientcommand, "Command", "-score", 0, ent, ent)
    //     }
    // }

    // Random Turret and Frankenturret colors and models, but once!
    if (Config_RandomTurret) {
        for (local turret = null; turret = Entities.FindByClassname(turret, "npc_portal_turret_floor");) {
            local modelnumber = RandomInt(0, 2)
            if (modelnumber == 2) {
                modelnumber = 4
            }
            turret.__KeyValueFromInt("ModelIndex", modelnumber)
            local model = RandomInt(0, 2)

            if (model == 1) {
                turret.SetModel("models/npcs/turret/turret_skeleton.mdl")
            } else if (model == 2) {
                turret.SetModel("models/npcs/turret/turret_backwards.mdl")
            }

            local randTurretColor = RandomColor()
            local r = randTurretColor.r
            local g = randTurretColor.g
            local b = randTurretColor.b

            EntFireByHandle(turret, "Color", (r + " " + g + " " + b), 0, null, null)
        }
        for (local frank = null; frank = Entities.FindByClassname(frank, "prop_monster_box");) {
            local randFrankColor = RandomColor()
            local r = randFrankColor.r
            local g = randFrankColor.g
            local b = randFrankColor.b

            EntFireByHandle(frank, "Color", (r + " " + g + " " + b), 0, null, null)
        }
    }

    // Code used to handle running VScript debugging on the host
    // This needs to be called in PostPlayerSpawn, because the game is in a state where `script_debug` will work as intended.
    if (Config_VScriptDebug) {
        printlP2MM(0, false, "[DEBUGGING] Initiating VScript Debugging!")

        // Developer is needed for debugging to work.
        // Just turning it on will work, but the debugger will act 
        // strange when the map loaded doesn't start with developer enabled,
        // so the map needs to be restarted for it act as expected.
        if (!GetDeveloperLevel()) {
            printlP2MM(1, false, "[DEBUGGING] \"developer\" isn't set to 1! Setting to 1 and restarting the map!")
            EntFire("p2mm_servercommand", "command", "developer 1")
            EntFire("p2mm_servercommand", "command", "changelevel " + GetMapName())
        }

        // Make the text to indicate that the game is frozen waiting for the VScript debugger
        vscriptDebugText <- Entities.CreateByClassname("game_text")
        vscriptDebugText.__KeyValueFromString("targetname", "vscriptDebugText")
        vscriptDebugText.__KeyValueFromString("x", "-1")
        vscriptDebugText.__KeyValueFromString("y", "-1")
        vscriptDebugText.__KeyValueFromString("holdtime", "1")
        vscriptDebugText.__KeyValueFromString("fadeout", "0.2")
        vscriptDebugText.__KeyValueFromString("fadein", "0.2")
        vscriptDebugText.__KeyValueFromString("channel", "1")
        vscriptDebugText.__KeyValueFromString("spawnflags", "1")
        vscriptDebugText.__KeyValueFromString("color", "255 255 255")
        vscriptDebugText.__KeyValueFromString("message", "Waiting for VScript Debugger to Attach...\nGAME WON'T UNFREEZE UNTIL\nDEBUGGER IS ATTACHED!")
        EntFireByHandle(vscriptDebugText, "Display", "", 0.2, null, null)

        // Call `script_debug` only on the host, that way other players will not be frozen.
        // But those same players can disconnect from the server due to time out if the host
        // does not connect the debugger quick enough unfreezing their game.
        EntFire("p2mm_servercommand", "command", "script_debug", 1, Entities.FindByName(null, "blue"))

        // `script_debug` takes a second to do its thing, so delay the debug message
        EntFire("p2mm_servercommand", "command", "script printlP2MM(\"[DEBUGGING] VScript Debugger Attached!\")", 1.1)

        // Reuse the same `game_text` entity to display a success message
        EntFireByHandle(vscriptDebugText, "settext", "VScript Debugger Attached!", 2, null, null)
        EntFireByHandle(vscriptDebugText, "Display", "", 2.5, null, null)

        // Remove the `game_text` and vscriptDebugText instance as they're not needed anymore
        EntFireByHandle(vscriptDebugText, "Kill", "", 4, null, null)
        delete vscriptDebugText
    }

    // Display First Run Prompt
    if (Config_FirstRunPrompt) {
        EntFire("p2mm_servercommand", "command", "script CallFirstRunPrompt()", 1)
    } 
}

// 4
function PostMapSpawn() {
    // Trigger map-specific code
    MapSupport(false, false, false, true, false, false, false)

    if (!IsDedicatedServer()) {
        SetMaxPortalSeparationConvar(Config_SetPlayerElasticity)
    }

    //## Cheat detection ##//
    EntFire("p2mm_servercommand", "command", "script SetCheats()")

    // Edit cvars & set server name
    EntFire("p2mm_servercommand", "command", "mp_allowspectators 1")
    if (PluginLoaded && !IsDedicatedServer()) {
        EntFire("p2mm_servercommand", "command", "hostname Portal 2: Multiplayer Mod Server hosted by " + GetPlayerName(1))
    } else {
        EntFire("p2mm_servercommand", "command", "hostname Portal 2: Multiplayer Mod Server")
    }

    // Force spawn players in map
    if (!g_bIsCommunityCoopHub) {
        AddBranchLevelName(1, "P2:MM")
    }
    CreatePropsForLevel(true, false)

	// Elastic Player Collision
	EntFire("p2mm_servercommand", "command", "portal_use_player_avoidance 1", 1)

	// Aliases for easier changelevel for custom maps
	EntFire("p2mm_servercommand", "command", "alias gelocity1 changelevel workshop/596984281130013835/mp_coop_gelocity_1_v02")
	EntFire("p2mm_servercommand", "command", "alias gelocity2 changelevel workshop/594730048530814099/mp_coop_gelocity_2_v01")
	EntFire("p2mm_servercommand", "command", "alias gelocity3 changelevel workshop/613885499245125173/mp_coop_gelocity_3_v02")

    // Set original angles
    EntFire("p2mm_servercommand", "command", "script g_bCanCheckAngle = true", 0.32)

    Entities.FindByClassname(null, "player").SetHealth(230053963)

    EntFire("p2mm_servercommand", "command", "script Entities.FindByName(null, \"blue\").SetHealth(230053963)", 0.9)
    EntFire("p2mm_servercommand", "command", "script g_bCanHook = true", 1)

    // Precache different turret models for when Config_RandomTurret or Config_RandomTurretLoop are true
    if (Config_RandomTurret || Config_RandomTurretLoop) {
        PrecacheModel("models/npcs/turret/turret_skeleton.mdl")
        PrecacheModel("models/npcs/turret/turret_backwards.mdl")
    }

    PostMapSpawnDone = true
}

// 5
function OnPlayerJoin(p) {

    // // Update this value. We don't want to run this several times
    // // at once if players are joining all at once (i.e. map change)
    // LastTimePlayerJoined <- Time()

    // // TODO: Find out how to get the number of players
    // // *connected* to the server and have yet to spawn

    // /*-------------------------------------------------------------
    // General notes about joining players:
    // - Their entity index is preserved throughout map loads and only
    //   changes if they leave the session. It is designated from "1"
    //   and higher until the first "team_manger" entity. That gives us
    //   a hint on what the current max players are in the server

    // - They spawn a few entities including:
    //    - player,                             CPortal_Player
    //       - Has a targetname of either "blue" or "red", depending on
    //         the team assigned to upon spawn

    //     (The rest of these have NO targetname by default)

    //    - predicted_viewmodel,                CPredicted_ViewModel

    // If the team portal gun spawning is NOT suppressed,
    // then these will also spawn for that specific player:

    //    - portalsimulator_collisionentity,    CPSCollisionEntity
    //    - prop_portal,                        CProp_Portal
    //    - weapon_portalgun,                   CWeaponPortalgun

    // The reason this whole thing is important is because if the map
    // is really big and contains a lot of entities, we don't want
    // players to spawn with the portal gun. Otherwise, the server
    // will crash due to hitting the max entity cap.
    // -------------------------------------------------------------*/

    // if (Time() - LastTimePlayerJoined <= 0.5 && CalcNumPlayers() > 10) {
    //     // URGENT: WE MUST FIND OUT IF THERE ARE TOO MANY PLAYERS
    //     // 20 players crashed me with the entity limit on mp_coop_lobby_3 - Nano
    //     // If we want 33 player Portal MP, we need to learn when to cut corners :)

    //     // Methods to iterate over EVERY entity present:
    //     /* 1.
    //         local entity = Entities.First()
    //         for (local entity = null; entity = Entities.Next(entity);) {
    //             printl(entity.entindex() + " - " + entity.GetClassname() + " - " + entity.GetName())
    //         }*/

    //     /* 2.
    //         for (local entity = Entities.First(); entity = Entities.Next(entity);) {
    //             printl(entity.entindex() + " - " + entity.GetClassname() + " - " + entity.GetName())
    //         }*/

    //     local bShouldRemovePortalguns = false
    //     local iCurrentNumEntsInLoop = 0

    //     // Find every entity and check their properties
    //     // TODO: FIX THIS METHOD. IT IS SLOW!!!
    //     for (local entity = Entities.First(); entity = Entities.Next(entity);) {
    //         iCurrentNumEntsInLoop++ // increment immediately

    //         // 1950 is nearing the entity limit. At this point, the host
    //         // has like 30 fps. We need to make an optimzation ASAP.
    //         if (entity.entindex() >= 2000) {
    //             bShouldRemovePortalguns = true
    //             break
    //         }
    //     }

    //     // Remove Portal Gun and change map
    //     if (bShouldRemovePortalguns) {
    //         SendChatMessage("***THIS MAP IS VERY BIG AND/OR THERE ARE A LOT OF PLAYERS CONNECTED!***", Entities.FindByClassname(null, "player"))
    //         SendChatMessage("***STRIPPING ALL PORTAL GUNS TO IMPROVE PERFORMANCE AND PREVENT A CRASH! TRANSITIONING TO mp_coop_doors IN 3 SECONDS***", Entities.FindByClassname(null, "player"))

    //         UTIL_Team.Spawn_PortalGun(false)
    //         RemoveAllClassname("weapon_portalgun")
    //         EntFire("p2mm_servercommand", "command", "changelevel mp_coop_doors", 3)
    //     } else {
    //         printl("-----------WE DONT NEED TO REMOVE THE GUNS AND CHANGE LEVEL!!!")
    //     }
    // }

    //-------------------------------------------------------------
    // Update P2:MM code

    p.ValidateScriptScope()
    local script_scope = p.GetScriptScope()

    // Trigger map-specific code
    MapSupport(false, false, false, false, true, false, false)

    // foreach (player in playersconnected) {
    //     if (player != p) {
    //         playersconnected.push(p)
    //     } else {
    //         // Should never happen
    //         printlP2MM("\"playersconnected\" array already had the player registered? Fix this...")
    //     }
    // }

    // Is this player being teleported based on the predictions/calculations
    // of the locations of entities in the map?
    if (GlobalSpawnClass.m_bUseAutoSpawn) {
        TeleportToSpawnPoint(p, null)
    }

    // Get player's index and store it
    PlayerID = p.GetRootMoveParent().entindex()

    // Assign every new targetname to the player after blue and red are used
    if (PlayerID >= 3) {
        p.__KeyValueFromString("targetname", "player" + PlayerID)
    }

    // Change player prop_portal targetname
    local ent1 = null
    local ent2 = null
    local portal1 = null
    local portal2 = null
    for (local ent = null; ent = Entities.FindByClassname(ent, "prop_portal");) {
        if (ent.GetName() == "") {
            if (ent1 == null) {
                ent1 = ent
            } else {
                ent2 = ent
            }
        }
    }

    try {
        if (ent1.entindex() > ent2.entindex()) {
            ent1.__KeyValueFromString("targetname", "player" + p.entindex() + "_portal" + "2")
            ent2.__KeyValueFromString("targetname", "player" + p.entindex() + "_portal" + "1")
            portal1 = ent2
            portal2 = ent1
        } else {
            ent1.__KeyValueFromString("targetname", "player" + p.entindex() + "_portal" + "1")
            ent2.__KeyValueFromString("targetname", "player" + p.entindex() + "_portal" + "2")
            portal1 = ent1
            portal2 = ent2
        }
        CreateEntityClass(portal1)
        CreateEntityClass(portal2)
        FindEntityClass(portal1).linkedprop <- null
        FindEntityClass(portal2).linkedprop <- null
    } catch (exception) {
        printlP2MM(1, true, "Failed to rename portals: " + exception)
    }

    //# Set viewmodel targetnames so they can be told apart #//
    for (local ent; ent = Entities.FindByClassname(ent, "predicted_viewmodel");) {
        EntFireByHandle(ent, "AddOutput", "targetname predicted_viewmodel_player" + ent.GetRootMoveParent().entindex(), 0, null, null)
    }

    // If the player is the first player to join, fix OrangeOldPlayerPos
    if (p.GetTeam() == TEAM_RED) {
        if (OrangeCacheFailed) {
            OrangeOldPlayerPos = p.GetOrigin()
            OrangeCacheFailed = false
        }
    }

    switch (PlayerID) {
        case 1:
            // Run general map code after a player loads into the game
            PostMapSpawn()
            break
        case 2:
            if (!g_bIsCommunityCoopHub) {
                // Run code after player 2 joins
                if (!g_bCheatsOn) {
                    if (IsDedicatedServer()) {
                        EntFire("p2mm_servercommand", "command", "sv_cheats 0")
                    } else {
                        EntFire("p2mm_servercommand", "command", "hud_saytext_time 0; sv_cheats 0; hud_saytext_time 12")
                    }
                }
                Player2Joined = true
            }
            break
    }

    EntFire("p2mm_servercommand", "command", "sv_timeout -1")
    EntFire("p2mm_servercommand", "command", "con_filter_enable 1; con_filter_text_out \"EntryMatchList\"") // Blocks repeated sound errors at around 13 players

    // Motion blur is very intense for some reason
    //! BROKEN BY VALVE! ANY FIXES ARE APPRECIATED!
    //EntFireByHandle(p2mm_clientcommand, "Command", "stopvideos; r_portal_fastpath 0; r_portal_use_pvs_optimization 0; mat_motion_blur_forward_enabled 0", 0, p, p)

    // SETUP THE CLASS /////////////////
    local currentplayerclass = CreateGenericPlayerClass(p)

    // UPDATE THE CLASS
    FindPlayerClass(p).portal1 = portal1
    FindPlayerClass(p).portal2 = portal2

    /////////////////////////////////////

    // Show scoreboard
    //! BROKEN BY VALVE! ANY FIXES ARE APPRECIATED!
    // if (!IsLocalSplitScreen() && !IsDedicatedServer() && !g_bIsCommunityCoopHub && !Player2Joined) {
    //     local p = Entities.FindByClassname(null, "player")
    //     if (FindPlayerClass(p).id == 1) {
    //         EntFireByHandle(p2mm_clientcommand, "Command", "+score", 0, p, p)
    //     }
    // }

    // Don't show the join text for the listen server host
    // TODO: Possibly need to rework "y" offset for dedicated?
    if (Config_UseJoinIndicator && PlayerID > 1) {
        // Set join message to player name (or index)
        local iCurrentNumPlayers = CalcNumPlayers()
        Entities.FindByName(null, "p2mm_player_joined_text").__KeyValueFromString("message", GetPlayerName(PlayerID) + " joined the game (" + iCurrentNumPlayers.tostring() + "/" + iMaxPlayers.tostring() + ")")
        waitingtext.__KeyValueFromString("y", "0.075")
        
        //# Say join message on HUD #//
        EntFireByHandle(Entities.FindByName(null, "p2mm_player_joined_text"), "Display", "", 0.0, null, null)
    }

    // Set color of player's in-game model
    local pcolor = GetPlayerColor(p, false)
    EntFireByHandle(p, "Color", (pcolor.r + " " + pcolor.g + " " + pcolor.b), 0, null, null)
    script_scope.Colored <- true

    // Set dev cosmetics
    if (Config_UseCustomDevModels && PluginLoaded) {
        // Currently doesn't work on dedicated... need a new way to precache models for everyone
        if (!IsDedicatedServer()) {
            switch (FindPlayerClass(p).steamid) {
                case 290760494: SetPlayerModel(p, "models/props_foliage/mall_tree_medium01.mdl");       break; // Nanoman2525
                case 182933216: SetPlayerModel(p, "models/info_character/info_character_player.mdl");   break; // kyleraykbs
                case 242453954: SetPlayerModel(p, "models/car_wrecked_dest/car_wrecked_b.mdl");         break; // sear
                case 181670710: SetPlayerModel(p, "models/handles_map_editor/torus.mdl");               break; // Bumpy
            }
        }
    }

    // Set fog controller
    if (g_bHasSpawned) {
        if (usefogcontroller) {
            EntFireByHandle(p, "setfogcontroller", defaultfog, 0, null, null)
        }
    }
}

// 6
function OnDeath(p) {

    // Put dead players in the dead players array
    foreach (player in CurrentlyDead) {
        if (player == p) {
            return
        }
    }
    CurrentlyDead.push(p)

    // Trigger map-specific code
    MapSupport(false, false, false, false, false, p, false)

    printlP2MM(0, true, FindPlayerClass(p).username + " died! OnDeath() has been triggered.")
}

// 7
function OnRespawn(player) {
    // Trigger map-specific code
    MapSupport(false, false, false, false, false, false, player)

    printlP2MM(0, true, FindPlayerClass(player).username + " respawned! OnRespawn() has been triggered.")

    // GlobalSpawnClass teleport
    if (GlobalSpawnClass.m_bUseAutoSpawn) {
        TeleportToSpawnPoint(player, null)
    }
}
