//---------------------------------------------------
//         *****!Do not edit this file!*****
//---------------------------------------------------
// Purpose: Here, we declare some functions to call
//                upon later in the code.
//---------------------------------------------------

function GetHighest(inpvec) {
    local highest = -99999999
    local highesttemp = -99999999
    if (UnNegative(inpvec.x) > highesttemp) {
        highesttemp = UnNegative(inpvec.x)
        highest = inpvec.x
    }
    if (UnNegative(inpvec.y) > highesttemp) {
        highesttemp = UnNegative(inpvec.y)
        highest = inpvec.y
    }
    if (UnNegative(inpvec.z) > highesttemp) {
        highesttemp = UnNegative(inpvec.z)
        highest = inpvec.z
    }
    return highest
}

function ForceRespawnAll() {
    // GlobalSpawnClass teleport
    if (GlobalSpawnClass.m_bUseAutoSpawn) {
        for (local p = null; p = Entities.FindByClassname(p, "player");) {
            TeleportToSpawnPoint(p, null)
        }
    }
}

function SetCheats() {
    g_bCheatsOn = Entities.FindByModel(null, "models/cheatdetectionp2mm.mdl")
    if (g_bCheatsOn == null || !g_bCheatsOn) {
        g_bCheatsOn = false
    } else {
        g_bCheatsOn = true
        Entities.FindByModel(null, "models/cheatdetectionp2mm.mdl").Destroy()
    }
}

function RandomColor() {
    local rcr = RandomInt(0, 255)
    local rcg = RandomInt(0, 255)
    local rcb = RandomInt(0, 255)
    local ColorBal = RandomInt(0, 2)
    // Balance the color
    if (rcr > rcg && rcr > rcb) {
        rcr = rcr * 2
        if (rcr > 255) {
            rcr = 255
        }
        if (ColorBal == 1) {
            rcg = rcg / 2
            rcb = rcb / 2
        }
        if (ColorBal == 2) {
            rcg = rcg * 2
            if (rcg > 255) {
                rcg = 255
            }
        rcb = rcb / 3
        }
    } else {
        if (rcg > rcr && rcg > rcb) {
            rcg = rcg * 2
            if (rcg > 255) {
                rcg = 255
            }
            if (ColorBal == 1) {
                rcr = rcr / 2
            }
            if (ColorBal == 2) {
                rcr = rcr * 2
                if (rcr > 255) {
                    rcr = 255
                }
            }
            rcg = rcg / 2
        } else {
            if (rcb > rcr && rcb > rcg) {
                rcb = rcb * 2
                if (rcb > 255) {
                    rcb = 255
                }
                rcr = rcr / 2
                rcg = rcg / 2
                if (ColorBal == 2) {
                    rcr = R / 2
                    rcg = rcg * 2
                    if (rcg > 255) {
                    rcg = 255
                    }
                }
            }
        }
        return class {
            r = rcr
            g = rcg
            b = rcb
        }
    }

    if (RandomInt(1, 7)==3) {
        rcg = RandomInt(1, 30)
        rcb = RandomInt(1, 30)
        rcr = RandomInt(170, 255)
    }
    if (RandomInt(1, 9)==4) {
        rcg = RandomInt(150, 255)
        rcb = RandomInt(1, 30)
        rcr = RandomInt(170, 255)
    }

    return class {
        r = rcr
        g = rcg
        b = rcb
    }
}

function TeleportPlayerToClass(player, curclass) {
    player.SetOrigin(curclass.pos)
    player.SetAngles(curclass.rot.x, curclass.rot.y, curclass.rot.z)
}

function p2mmfogswitch(fogname) {
    printlP2MM("Switching to fog: " + fogname)
    foreach (fogclass in fogs) {
        if (fogclass.fogname == fogname) {
            printlP2MM("Found fog: " + fogclass.fogname)
            // go through each player and set their fog to the new fog
            for (local p = null; p = Entities.FindByClassname(p, "player");) {
                EntFireByHandle(p, "setfogcontroller", fogname, fogclass.fogdelay, null, null)
            }
            defaultfog <- fogname
        }
    }
}

/*function GetPlayerPortalColor(p, Darken = false) {
    local PlayerID = p.entindex() + amtoffsetclr
    local A = 220
    try {
        switch (PlayerID) {
            case 1 : R <- 255; G <- 255; B <- 255; A = A; break; //bright white
            case 2 : R <- 50,  G <- 255, B <-  50; A = A; break; //green
            case 3 : R <- 40,  G <- 60,  B <- 255; A = A; break; //blue
            case 4 : R <- 255, G <- 255, B <-  50; A = A; break; //orange
            case 5 : R <- 255, G <-  50, B <-  50; A = A; break; //red
            case 6 : R <- 255, G <- 100, B <- 255; A = A; break; //pink
            case 7 : R <- 255, G <- 255, B <-  50; A = A; break; //yellow
            case 8 : R <-  0 , G <- 255, B <- 255; A = A; break; //aqua
            case 9 : R <- 100, G <-  50, B <-   0; A = A; break; //brown
            case 10: R <-   0, G <- 255, B <- 200; A = A; break; //ocean green
            case 11: R <-  90, G <- 120, B <-   0; A = A; break; //olive
            case 12: R <-  90, G <-  70, B <- 100; A = A; break; //violet
            case 13: R <-  75, G <-  75, B <-  75; A = A; break; //gray
            case 14: R <-  75, G <-   0, B <-   0; A = A; break; //dark red
            case 15: R <-   0, G <-  75, B <-   0; A = A; break; //dark green
            case 16: R <-   0, G <-   0, B <-  75; A = A; break; //dark blue
        }
    } catch(e) { }
    if (PlayerID > 16) {
        // If you have more than 16 players then you gotta bear the consequences of your own actions
        local randomColor = RandomColor()
        R <- randomColor.r; G <- randomColor.g; B <- randomColor.b; A = 250;
    }

    if (Darken) {
        local amt = 2
        printlP2MM("Darkening color")
        printlP2MM("R: " + R + " G: " + G + " B: " + B)
        R <- (R / amt);
        G <- (G / amt);
        B <- (B / amt);
        printlP2MM("R: " + R + " G: " + G + " B: " + B)
        if (R < 1) {
            R <- 1;
        }
        if (G < 1) {
            G <- 1;
        }
        if (B < 1) {
            B <- 1;
        }

        // remove the decimal
        B <- B.tointeger()
        G <- G.tointeger()
        R <- R.tointeger()
    }

    return class {
        r = R
        g = G
        b = B
        a = A
    }
}*/

// Used so that nametags appear less weird
function MultiplyRGBValue(iRGBValue) {
    // Multiply the color
    if (iRGBValue >= 100) {
        iRGBValue = iRGBValue - 100
    }
    // cap the color at 255
    if (iRGBValue > 255) {
        iRGBValue = 255
    }
    // bottom the color at 0
    if (iRGBValue < 0) {
        iRGBValue = 0
    }
    return iRGBValue
}

function GetColorByName(color) {
    local vColor = color.tolower()
    local id = 0
    switch (vColor) {
        case "white"  :  id = 1    ; break;
        case "green"  :  id = 2    ; break;
        case "blue"   :  id = 3    ; break;
        case "orange" :  id = 4    ; break;
        case "red"    :  id = 5    ; break;
        case "pink"   :  id = 6    ; break;
        case "yellow" :  id = 7    ; break;
        case "aqua"   :  id = 8    ; break;
        case "crimson":  id = 9    ; break;
        case "lime"   :  id = 22   ; break;
        case "purple" :  id = 24   ; break;
        case "cyan"   :  id = 26   ; break;
        case "black"  :  id = 27   ; break;
        case "teal"   :  id = 28   ; break;
        case "olive"  :  id = 11   ; break;
        case "violet" :  id = 12   ; break;
        case "gray"   :  id = 13   ; break;
        case "random" :  id = 69420; break;
        default: return null        
    }
    return GetPlayerColor(id, false)
}

function GetPlayerColor(p, multiply = true) {
    local PlayerID
    if (typeof p == "integer") {
        PlayerID = p
    } else {
        PlayerID = p.entindex() + amtoffsetclr
    }
    local colorname
    try {
        switch (PlayerID) {
            case 1 : R <- 255; G <- 255; B <- 255;  colorname = "White";            break;
            case 2 : R <- 180, G <- 255, B <- 180;  colorname = "Green";            break;
            case 3 : R <- 120, G <- 140, B <- 255;  colorname = "Blue";             break;
            case 4 : R <- 255, G <- 170, B <- 120;  colorname = "Orange";           break;
            case 5 : R <- 255, G <- 100, B <- 100;  colorname = "Red";              break;
            case 6 : R <- 255, G <- 180, B <- 255;  colorname = "Pink";             break;
            case 7 : R <- 255, G <- 255, B <- 180;  colorname = "Yellow";           break;
            case 8 : R <-  0 , G <- 255, B <- 255;  colorname = "Aqua";             break;
            case 9 : R <-  60, G <-  15, B <-   0;  colorname = "Crimson";          break;
            case 10: R <-   0, G <- 255, B <- 200;  colorname = "Ocean Green";      break;
            case 11: R <-  80, G <-  99, B <-   0;  colorname = "Olive";            break;
            case 12: R <-  40, G <-  40, B <-  80;  colorname = "Violet";           break;
            case 13: R <-  75, G <-  75, B <-  75;  colorname = "Gray";             break;
            case 14: R <-  64, G <-   0, B <-   0;  colorname = "Dark Red";         break;
            case 15: R <-   0, G <-  64, B <-   0;  colorname = "Dark Green";       break;
            case 16: R <-   0, G <-   0, B <-  64;  colorname = "Dark Blue";        break;
            case 17: R <- 255, G <-  87, B <-  51;  colorname = "Scarlet";          break;
            case 18: R <- 165, G <- 208, B <- 255;  colorname = "Bright Blue";      break;
            case 19: R <- 190, G <- 255, B <- 200;  colorname = "Mint Green";       break;
            case 20: R <- 205, G <- 207, B <-  62;  colorname = "Gold Yellow";      break;
            case 21: R <- 255, G <- 194, B <- 194;  colorname = "Bright Red";       break;
            case 22: R <- 208, G <- 255, B <-  28;  colorname = "Lime";             break;
            case 23: R <-  91, G <- 129, B <- 184;  colorname = "Dull Blue";        break;
            case 24: R <-  99, G <-   0, B <- 161;  colorname = "Purple";           break;
            case 25: R <- 107, G <- 169, B <- 117;  colorname = "Dull Green";       break;
            case 26: R <-  56, G <- 191, B <- 188;  colorname = "Cyan";             break;
            case 27: R <-  11, G <-  11, B <-  11;  colorname = "Black";            break;
            case 28: R <- 103, G <- 233, B <- 197;  colorname = "Teal";             break;
            case 29: R <- 183, G <- 135, B <- 223;  colorname = "Bright Magenta";   break;
            case 30: R <- 120, G <- 195, B <- 193;  colorname = "Blue Gray";        break;
            case 31: R <- 138, G <-  89, B <-   0;  colorname = "Dark Orange";      break;
            case 32: R <- 236, G <- 167, B <- 167;  colorname = "Light Red";        break;
            case 33: R <-   0, G <- 100, B <- 150;  colorname = "Navy Blue";        break;
        }
    } catch (exception) {}

    if (PlayerID > 33) {
        // No dedicated color for player indexes above 33 atm
        local randomColor = RandomColor()
        R <- randomColor.r; G <- randomColor.g; B <- randomColor.b; colorname = "Random";
    }

    // Do we want to make the color less "bright"?
    if (multiply) {
        R = MultiplyRGBValue(R)
        G = MultiplyRGBValue(G)
        B = MultiplyRGBValue(B)
    }

    // We want the color exactly how we asked for it
    return class {
        r = R
        g = G
        b = B
        name = colorname
    }
}

function CreateTrigger(desent, x1, y1, z1, x2, y2, z2){
    if (GetDeveloperLevelP2MM()){
        DebugDrawBox(Vector(x1, y1, z1), Vector(0, 0, 0), Vector(x2-x1, y2-y1, z2-z1), 255, 100, 8, 20, TickSpeed*1.17);
    }

    local TransitionVariable = 0
    if (x1 >= x2) {
        TransitionVariable = x2
        x2 = x1
        x1 = TransitionVariable
    }

    local TransitionVariable = 0
    if (y1 >= y2) {
        TransitionVariable = y2
        y2 = y1
        y1 = TransitionVariable
    }

    local TransitionVariable = 0
    if (z1 >= z2) {
        TransitionVariable = z2
        z2 = z1
        z1 = TransitionVariable
    }

    local plist = []
    local outputp = null
    if (desent == null) {
        for (local p = null; p = Entities.FindInSphere(p, Vector(0, 0, 0), 16384);) {
            local pos = p.GetOrigin()
            if (pos.x >= x1 && pos.x <= x2){
                if (pos.y >= y1 && pos.y <= y2){
                    if (pos.z >= z1 && pos.z <= z2){
                        plist.push(p)
                    }
                }
            }
        }
    } else {
        for (local p = null; p = Entities.FindByClassname(p, desent);) {
            local pos = p.GetOrigin()
            if (pos.x >= x1 && pos.x <= x2){
                if (pos.y >= y1 && pos.y <= y2){
                    if (pos.z >= z1 && pos.z <= z2){
                        plist.push(p)
                    }
                }
            }
        }
    }
    return plist
}

function SetPlayerModel(p, mdl) {
    PrecacheModel(mdl)
    FindPlayerClass(p).playermodel = mdl
}

function CreateGenericPlayerClass(p) {
    // Make sure there isnt an existing player class
    foreach (indx, curlclass in playerclasses) {
        if (curlclass.player == p) {
            // If there is, remove it (This should never happen)
            playerclasses.remove(indx)
            break
        }
    }

    local currentplayerclass = {}

    // Base info
    currentplayerclass.color <- GetPlayerColor(p)  // Player color
    currentplayerclass.eyeangles <- Vector(0, 0, 0) // Player angles
    currentplayerclass.eyeforwardvector <- Vector(0, 0, 0) // Player angles
    currentplayerclass.id <- p.entindex() // Player entity index
    currentplayerclass.noclip <- p.IsNoclipping() // Player noclip status
    currentplayerclass.player <- p // The player reference in code
    currentplayerclass.playermodel <- null // Cosmetics
    currentplayerclass.potatogun <- false // Potatogun
    currentplayerclass.portal1 <- null // Player primary portal
    currentplayerclass.portal2 <- null // Player secondary portal

    // Gelocity
    if (GetMapName() == "workshop/596984281130013835/mp_coop_gelocity_1_v02" ||
        GetMapName() == "workshop/594730048530814099/mp_coop_gelocity_2_v01" ||
        GetMapName() == "workshop/613885499245125173/mp_coop_gelocity_3_v02") {
        currentplayerclass.nCurrentLap <- 1 // Current lap
        currentplayerclass.GelocityCheckPointType <- 0 // Player checkpoint status (<- LAP_CHECKPOINT1)

        // TEMP
        if (GetMapName() == "workshop/594730048530814099/mp_coop_gelocity_2_v01") {
            currentplayerclass.Gelocity2Checkpoint <- true
            currentplayerclass.Gelocity2CheckpointMove <- class {
                pos = Vector(2580, -4399,  267)
                rot = Vector(0, 90, 0)
            }
        }
    }

    // Can change depending on whether the plugin is loaded
    currentplayerclass.username <- GetPlayerName(currentplayerclass.id) // Player Name
    currentplayerclass.steamid <- GetSteamID(currentplayerclass.id) // Player Steam ID

    // Chat commands
    if (Config_UseChatCommands && PluginLoaded) {
        currentplayerclass.rocket <- false  // Rocket player status
        currentplayerclass.startedvote <- false  // Did this player initiate a vote?
        currentplayerclass.hasvotedyes <- false  // Did this player vote yes?
        currentplayerclass.hasvotedno <- false  // Did this player vote no?
    }

    // Note down the registered player for later reference
    playerclasses.push(currentplayerclass)

    return currentplayerclass
}

// function GetEntityCount(classname = null) {
//     if (classname == null) {
//         local indx = 0
//         for (local p = null; p = Entities.FindInSphere(p, Vector(0, 0, 0), 100000);) {
//             indx += 1
//         }
//         return indx
//     } else {
//         local indx = 0
//         for (local p = null; p = Entities.FindByClassname(p, classname);) {
//             indx += 1
//         }
//         return indx
//     }
// }

function DeleteAmountOfEntities(classname, amount) {
    local indx = 0
    for (local p; p = Entities.FindByClassname(p, classname);) {
        if (indx >= amount) {
            break
        }

        local delthis = true
        local checkClassname = p.GetRootMoveParent().GetClassname()

        if (checkClassname == "player" || checkClassname == "worldspawn" || checkClassname == "" || checkClassname == "prop_portal") {
            delthis = false
            printlP2MM("Not deleting class " + classname + " (ROOTMOVEPARENT: " + checkClassname + "). By deleting the class, the RootMoveParent will also get deleted, causing crashes.")
        }

        if (delthis) {
            p.Destroy()
            indx++
        }
    }
    printlP2MM("Deleted " + indx + " " + classname + "'s")
    return indx
}

function PrecacheModel(mdl) {
    // Add the models/ to the side of the model name if it's not already there
    if (mdl.slice(0, 7) != "models/") {
        mdl = "models/" + mdl
    }
    // Add the .mdl to the end of the model name if it's not already there
    if (mdl.slice(mdl.len() - 4, mdl.len()) != ".mdl") {
        mdl = mdl + ".mdl"
    }

    // Remove the models/ from the left side and the .mdl from the right side
    local MinifyModel = function(mdl) {
        if (mdl.slice(0, 7) == "models/") {
            mdl = mdl.slice(7, mdl.len())
        }
        if (mdl.slice(mdl.len() - 4, mdl.len()) == ".mdl") {
            mdl = mdl.slice(0, mdl.len() - 4)
        }
        return mdl
    }
    local minimdl = MinifyModel(mdl)

    // Check if the model is already precached
    local Precached = false
    foreach (model in PrecachedProps) {
        if (model == minimdl) {
            Precached = true
        }
    }

    // No existing model in the map and it's not something we know is precached
    if (!Entities.FindByModel(null, mdl) && !Precached) {
        // Attempt to precache it
        EntFire("p2mm_servercommand", "command", "sv_cheats 1; prop_dynamic_create " + minimdl) // FIXME: "prop_dynamic_create" crashes on dedicated servers!!!
        PrecachedProps.push(minimdl)
        if (!g_bCheatsOn) {
            // In case players are now joining
            EntFire("p2mm_servercommand", "command", "sv_cheats 0")
        }
        EntFire("p2mm_servercommand", "command", "script Entities.FindByModel(null, \"" + mdl + "\").Destroy()", 0.4)
        if (GetDeveloperLevelP2MM()) {
            printlP2MM("PrecacheModel() - Precached model: " + mdl)
        }
    } else {
        if (GetDeveloperLevelP2MM()) {
            printlP2MM("PrecacheModel() - Model: " + mdl + " already precached!")
        }
    }
}

function FindPlayerClass(plyr) {
    // If for whatever reason this function causes errors,
    // then there is a problem with how we hook onto joining players
    foreach (curclass in playerclasses) {
        if (curclass.player == plyr) {
            return curclass
        }
    }
}

function FindEntityClass(ent, createclassifnone = true) {
    foreach (curclass in entityclasses) {
        if (curclass.entity == ent) {
            return curclass
        }
    }
    printlP2MM("Could not find entity class for entity: " + ent)
    if (createclassifnone) {
        CreateEntityClass(ent)
        foreach (curclass in entityclasses) {
            if (curclass.entity == ent) {
                printlP2MM("Created entity class for entity: " + ent)
                return curclass
            }
        }
    }
}

function LineIntersect2D(point1start, point1end, point2start, point2end) {
    local d = (point1start.x - point1end.x) * (point2start.y - point2end.y) - (point1start.y - point1end.y) * (point2start.x - point2end.x)
    local a = point1start.x * point1end.y - point1start.y * point1end.x
    local b = point2start.x * point2end.y - point2start.y * point2end.x
    local x = (a * (point2start.x - point2end.x) - (point1start.x - point1end.x) * b) / d
    local y = (a * (point2start.y - point2end.y) - (point1start.y - point1end.y) * b) / d

    // calculate the z coordinate of the intersection point
    local z = point1start.z + (x - point1start.x) * (point1end.z - point1start.z) / (point1end.x - point1start.x)

    return Vector(x, y, z)
}

function CoreExplosion(coords) {
    local core = Entities.CreateByClassname("npc_personality_core")
    core.SetOrigin(coords)
    EntFire(core, "explode")
}

function TranslatePlayerToWall(wall, playerpos) {
    local line1 = wall[1]
    local line2 = wall[2]

    local dir = wall[0]

    local playerforward = Vector(0, 0, 0)
    if (dir == 0) {
        playerforward = Vector(5, 0, 0)
    } else {
        playerforward = Vector(0, 5, 0)
    }

    local intersect1 = Vector(0, 0, 0)
    // now find line 1's intersection with the player
    if (line1[2] == false) {
        intersect1 = LineIntersect2D(line1[0], line1[1], playerpos, playerpos + playerforward)
    } else {
        intersect1 = LineIntersect2DZTranslation(line1[0], line1[1], playerpos, playerpos + playerforward, dir)
    }

    local intersect2 = Vector(0, 0, 0)
    // now find line 2's intersection with the player
    if (line2[2] == false) {
        intersect2 = LineIntersect2D(line2[0], line2[1], playerpos, playerpos + playerforward)
    } else {
        intersect2 = LineIntersect2DZTranslation(line2[0], line2[1], playerpos, playerpos + playerforward, dir)
    }

    // get the final point (the intersection of the two lines)

    local finalpoint = Vector(0, 0, 0)
    if (dir == 0) {
        if (line1[2] == false) {
            finalpoint = Vector(intersect2.x, intersect1.y, intersect2.z)
        } else {
            finalpoint = Vector(intersect1.x, intersect2.y, intersect1.z)
        }
    } else {
        if (line1[2] == false) {
            finalpoint = Vector(intersect1.x, intersect2.y, intersect2.z)
        } else {
            finalpoint = Vector(intersect2.x, intersect1.y, intersect1.z)
        }
    }

    return finalpoint
}

function LineIntersect2DZTranslation(point1, point2, flatpoint1, flatpoint2, ztranslation) { // ztranslation is y flip = 0, x flip = 1

    // flip the line so we can send it to the 2D line intersect function
    if (ztranslation == 0) {
        point2 = FlipVectorsZY(point1, point2)
    } else {
        point2 = FlipVectorsZX(point1, point2)
    }

    // put the players coords on the same plane as the line
    if (ztranslation == 0) {
        flatpoint1 = FlipVectorsZY(point1, flatpoint1)
    } else {
        flatpoint1 = FlipVectorsZX(point1, flatpoint1)
    }

    // put the players coords on the same plane as the line
    if (ztranslation == 0) {
        flatpoint2 = FlipVectorsZY(point1, flatpoint2)
    } else {
        flatpoint2 = FlipVectorsZX(point1, flatpoint2)
    }

    // get the intersection
    local intersect = LineIntersect2D(point1, point2, flatpoint1, flatpoint2)

    // flip the intersection back to the original z
    if (ztranslation == 0) {
        intersect = FlipVectorsZY(point1, intersect)
    } else {
        intersect = FlipVectorsZX(point1, intersect)
    }

    return intersect
}

function FlipVectorsZY(midvec1, vec2) {
    vec2 = GlobalToLocal(vec2, midvec1)
    vec2 = Vector(vec2.x, vec2.z, vec2.y)

    vec2 = vec2 + midvec1
    return vec2
}

function FlipVectorsZX(midvec1, vec2) {
    vec2 = GlobalToLocal(vec2, midvec1)
    vec2 = Vector(vec2.z, vec2.y, vec2.x)

    vec2 = vec2 + midvec1
    return vec2
}

function GlobalToLocal(point1, middlepoint) {
    point1 = point1 - middlepoint

    return point1
}

function MultiplyVector(vec, mult) {
    return Vector(vec.x * mult, vec.y * mult, vec.z * mult)
}

function AddVectors(vec1, vec2) {
    return Vector(vec1.x + vec2.x, vec1.y + vec2.y, vec1.z + vec2.z)
}

function CreateEntityClass(ent) {
    if (GetDeveloperLevelP2MM()) {
        printlP2MM("Creating new entity class for entity: " + ent)
    }
    local newclass = class {
        entity = ent
        // TODO: What should be the default for this?
        // linkedprop = ???
        // followingpointlist = ???
        // followingpointlistindex = ???
    }
    entityclasses.push(newclass)
}

function GetDistanceScore(vec1, vec2) {
    local betweenvec = UnNegative(vec1 - vec2)
    local score = betweenvec.x + betweenvec.y + betweenvec.z
    return score
}

function MoveEntityOnTrack(entity, PointList, Speed = "undefined", Distance = "undefined") {
    if (Speed == "undefined") {
        Speed = 1
    }
    if (Distance == "undefined") {
        Distance = (Speed * 1.2) + 1
    }

    local entclass = FindEntityClass(entity)

    try {
        if (entclass.followingpointlist[0].x != PointList[0].x && entclass.followingpointlist[0].y != PointList[0].y && entclass.followingpointlist[0].z != PointList[0].z) {
            entclass.followingpointlist <- PointList
            entclass.followingpointlistindex <- 0
        }
    } catch(e) {
        entclass.followingpointlist <- PointList
        entclass.followingpointlistindex <- 0
    }

    local cindx = -1
    if (GetDistanceScore(entity.GetOrigin(), PointList[entclass.followingpointlistindex]) < Distance) {
        cindx = entclass.followingpointlistindex
        entclass.followingpointlistindex <- entclass.followingpointlistindex + 1
        printlP2MM("Moving to next track point: " + entclass.followingpointlistindex)
    }

    if (entclass.followingpointlistindex >= PointList.len()) {
        entclass.followingpointlistindex <- 0
        entclass.followingpointlist <- null
        return true
    }

    local offset = MultiplyVector(GetDirectionalOffset(entity.GetOrigin(), PointList[entclass.followingpointlistindex]), Speed)
    entity.SetOrigin(entity.GetOrigin() - offset)

    if (Config_VisualDebug) {
        DebugDrawLine(entity.GetOrigin(), PointList[entclass.followingpointlistindex], 255, 255, 0, true, 0)
        if (entclass.followingpointlistindex == 0) {
            DebugDrawLine(entity.GetOrigin(), PointList[PointList.len() - 1], 0, 255, 0, true, 0)
        } else {
            DebugDrawLine(entity.GetOrigin(), PointList[entclass.followingpointlistindex - 1], 0, 255, 0, true, 0)
        }

        local curindx = 0
        foreach (point in PointList) {
            DebugDrawBox(point, Vector(-5, -5, -5), Vector(5, 5, 5), 255, 255, 255, 100, 0)
            if (curindx != entclass.followingpointlistindex) {
                if (curindx == 0) {
                    DebugDrawLine(PointList[PointList.len() - 1], point, 255, 100, 255, true, 0)
                } else {
                    DebugDrawLine(PointList[curindx - 1], point, 255, 100, 255, true, 0)
                }
            }
            curindx = curindx + 1
        }
    }

    if (cindx == -1) {
        return false
    } else {
        return cindx
    }
}

function FindNearest(origin, radius, entitiestoexclude = [null], specificclass = null) {
    // Setup some existing locals
    try {
        entitiestoexclude[0]
    } catch(e) {
        // If this errors out we should probably put the defined ent into a table
        entitiestoexclude = [entitiestoexclude]
    }

    // Define some locals
    local bestscore = 999999999
    local nearestent = null

    // Find the nearest entity
    if (specificclass == null) {
        for (local ent = null; ent = Entities.FindInSphere(ent, origin, radius);) {
            // Check if the entity is in the list of entities to exclude
            local exclude = false
            // We only need to check if 1 ent equals to excluded that's why i added a break
            foreach (excluded in entitiestoexclude) {
                if (excluded == ent) {
                    exclude = true
                    break
                }
            }
            if (exclude == false) {
                // Get the score
                local score = origin - ent.GetOrigin()
                score = UnNegative(score)
                score = score.x + score.y + score.z
                // Check if the entity is closer than the current best
                if (score < bestscore) {
                    bestscore = score
                    nearestent = ent
                }
            }
        }
    } else {
        for (local ent = null; ent = Entities.FindByClassnameWithin(ent, specificclass, origin, radius);) {
            // Check if the entity is in the list of entities to exclude
            local exclude = false
            // We only need to check if 1 ent equals to excluded that's why i added a break
            foreach (excluded in entitiestoexclude) {
                if (excluded == ent) {
                    exclude = true
                    break
                }
            }
            if (exclude == false) {
                // Get the score
                local score = origin - ent.GetOrigin()
                score = UnNegative(score)
                score = score.x + score.y + score.z
                // Check if the entity is closer than the current best
                if (score < bestscore) {
                    bestscore = score
                    nearestent = ent
                }
            }
        }
    }

    // Return the nearest entity
    return nearestent
}

function ForwardVectorTraceLine(origin, forward, mindist = 0, maxdist = 10000, currentstepped = 4, stepmultiplier = 1, maxreldist = 32, entitiestoexclude = [null], specificclass = null) {
    // maxdist = maxdist / stepmultiplier

    // Setup some existing locals
    try {
        entitiestoexclude[0]
    } catch(e) {
        // If this errors out we should probably put the defined ent into a table
        entitiestoexclude = [entitiestoexclude]
    }

    // Define some locals
    local origorigin = origin // Preserve
    local origmindist = mindist // Preserve
    local origmaxdist = maxdist // Preserve
    local originoffset = Vector(forward.x, forward.y, forward.z) // Make sure we get outside of the desired min zone
    local fowardstep = forward // Vector(forward.x * currentstepped, forward.y * currentstepped, forward.z * currentstepped) // Multiply this se we can get a base step amount
    local outputorigin = Vector(0, 0, 0) // Output
    local nearestent = null // Output
    local clradd = 0
    local opadd = 0

    //# Trace the ray #//
    local loopamt = 0
    while (loopamt < currentstepped) {
        // Do some math setup
        local temporigin = origin + originoffset
        // Find the nearest ent within our maxdist
        nearestent = FindNearest(temporigin, origmaxdist, entitiestoexclude, specificclass)

        // Now that we have the nearest ent, we need to see how far it is from the temporigin
        if (nearestent == null) {
            return null
        }
        local score = temporigin - nearestent.GetOrigin()
        score = UnNegative(score)
        // Multiply forwards by the lowest value in the score
        local lowest = 0
        if (score.x > lowest) {
            lowest = score.x
        }
        if (score.y > lowest) {
            lowest = score.y
        }
        if (score.z > lowest) {
            lowest = score.z
        }

        fowardstep = Vector((forward.x * lowest), (forward.y * lowest), (forward.z * lowest))
        local deboogdatalarb = lowest - 50
        if (deboogdatalarb < 0) {
            deboogdatalarb = 0
        }

        clradd = clradd + 50
        opadd = opadd + 1
        if (Entities.FindByName(null, "blue") != entitiestoexclude[0]) {
            if (Config_VisualDebug) {
                DebugDrawBox(origin + originoffset, Vector(deboogdatalarb / -1, deboogdatalarb / -1, deboogdatalarb / -1), Vector(deboogdatalarb, deboogdatalarb, deboogdatalarb), 255 - clradd, 0, clradd, 0 + opadd, 0.1)
                DebugDrawBox(origin + originoffset, Vector(-10, -10, -10), Vector(10, 10, 10), 0, 255, 255, 10, 0.1)
            }
        }

        // Add the fowardstep to the origin
        originoffset = originoffset + fowardstep

        // After getting the end point, we need to see if we hit anything
        local newnearest = FindNearest(origin + originoffset, maxreldist, entitiestoexclude, specificclass)
        if (newnearest != null) {
            if (Config_VisualDebug) {
                DebugDrawLine(origorigin, origin + originoffset, 0, 255, 0, false, 0.1)
            }
            return newnearest
            break
        }
        loopamt = loopamt + 1
    }

    outputorigin = origin + originoffset
    if (Config_VisualDebug) {
        DebugDrawLine(origorigin, outputorigin, 0, 255, 0, false, 0.1)
    }
}

function DisplayPlayerColor(player) {
    if (!Entities.FindByName(null, "p2mm_playercolordisplay")) {
        p2mm_playercolordisplay <- Entities.CreateByClassname("game_text")
        p2mm_playercolordisplay.__KeyValueFromString("targetname", "p2mm_playercolordisplay")
        p2mm_playercolordisplay.__KeyValueFromString("holdtime", "5")
        p2mm_playercolordisplay.__KeyValueFromString("fadeout", "2")
        p2mm_playercolordisplay.__KeyValueFromString("fadein", "2")
        // p2mm_playercolordisplay.__KeyValueFromString("spawnflags", "0")
        p2mm_playercolordisplay.__KeyValueFromString("channel", "4")
        // p2mm_playercolordisplay.__KeyValueFromString("message", "")
        p2mm_playercolordisplay.__KeyValueFromString("x", "0.005")
        p2mm_playercolordisplay.__KeyValueFromString("y", "1")
    }
    EntFireByHandle(p2mm_playercolordisplay, "SetText", "Your color: " + FindPlayerClass(player).color.name, 0, player, player)
    EntFireByHandle(p2mm_playercolordisplay, "SetTextColor", FindPlayerClass(player).color.r + " " + FindPlayerClass(player).color.g + " " + FindPlayerClass(player).color.b, 0, player, player)
    EntFireByHandle(p2mm_playercolordisplay, "Display", "", 0, player, player)
    EntFireByHandle(p2mm_playercolordisplay, "Display", "", 0, player, player)
    EntFireByHandle(p2mm_playercolordisplay, "kill", "", 0.1, player, player)
}

function ColorDisassemblerAnimation(activator) {
    if (activator.GetTeam() == TEAM_BLUE) {
        local blueDisassemblerColor = FindPlayerClass(activator).color.r + " " + FindPlayerClass(activator).color.g + " " + FindPlayerClass(activator).color.b
        for (local ent = null; ent = Entities.FindByClassnameWithin(ent, "prop_dynamic", activator.GetOrigin(), 1);) {
            if (ent.GetName().find("blue-ballbot_assembler") != null) {
                EntFireByHandle(ent, "Color", blueDisassemblerColor, 0, null, null)
                break
            }
        }
    } else {
        local orangeDisassemblerColor = FindPlayerClass(activator).color.r + " " + FindPlayerClass(activator).color.g + " " + FindPlayerClass(activator).color.b
        for (local ent = null; ent = Entities.FindByClassnameWithin(ent, "prop_dynamic", activator.GetOrigin(), 1);) {
            if (ent.GetName().find("orange-ballbot_assembler") != null) {
                EntFireByHandle(ent, "Color", orangeDisassemblerColor, 0, null, null)
                break
            }
        }
    }
}

function FindAndReplace(inputstr, findstr, replacestr) {
    local startstrip = inputstr.find(findstr)
    if (startstrip==null) {
        return inputstr
    }
    local endstrip = startstrip + findstr.len()

    local newstr = inputstr.slice(0, startstrip) + replacestr + inputstr.slice(endstrip, inputstr.len())
    return newstr
}

function RemoveAllClassname(classname, delay = 0) {
    for (local p = null; p = Entities.FindByClassname(p, classname);) {
        if (delay == 0) {
            p.Destroy()
        } else {
            EntFireByHandle(p, "kill", "", delay, null, null)
        }
    }
}

function RemoveAllClassnameDistance(classname, pos, dist, delay = 0) {
    for (local p = null; p = Entities.FindByClassnameWithin(p, classname, pos, dist);) {
        EntFireByHandle(p, "kill", "", delay, null, null)
    }
}

function UnNegative(num) {
    try {
        local test = num.x

        if (num.x < 0) {
            num.x = num.x * -1
        }
        if (num.y < 0) {
            num.y = num.y * -1
        }
        if (num.z < 0) {
            num.z = num.z * -1
        }

        num = Vector(num.x, num.y, num.z)
    } catch(e) {
        if (num <= 0) { // TODO: Can cause errors with comparing instances
            num = num * -1
        }
    }
    return num
}

// Teleport players within a distance
function TeleportPlayerWithinDistance(SearchPos, SearchDis, TeleportDest) {
    for (local ent = null; ent = Entities.FindByClassnameWithin(ent, "player", SearchPos, SearchDis);) {
        ent.SetOrigin(TeleportDest)
    }
}

// Get directional offset
function GetDirectionalOffset(org1, org2, multipl = 1) {

    local bxoffset = org1 - org2

    // Get the highest number in bxoffset
    local highest = UnNegative(GetHighest(bxoffset))
    local wasneg = false
    // If it was originally negative then set the var
    if (GetHighest(bxoffset) < 0) {
        wasneg = true
    }

    // Divide it by the highest number
    // bxoffset.x <- bxoffset.x / highest
    // bxoffset.y <- bxoffset.y / highest
    // bxoffset.z <- bxoffset.z / highest
    // If highest is not 0
    if (highest > 0) {
        // I genuinely have no idea if this works, but if js can do it squirrel can too

        // If bxoffset.x is negative
        local wasxneg = bxoffset.x < 0

        // If bxoffset.y is negative
        local wasyneg = bxoffset.y < 0

        // If bxoffset.z is negative
        local waszneg = bxoffset.z < 0

        // Set the new values
        local newx = bxoffset.x / highest
        if (wasxneg && newx > 0) {
            newx = 0
        }
        local newy = bxoffset.y / highest
        if (wasyneg && newy > 0) {
            newy = 0
        }
        local newz = bxoffset.z / highest
        if (waszneg && newz > 0) {
            newz = 0
        }

        // Put the new values back into bxoffset
        bxoffset = Vector(newx*multipl, newy*multipl, newz*multipl)

    }

    return bxoffset
}

// Potatogun
function PotatoIfy(plr, charOnOff) {
    local pGun = Entities.FindByName(null, "weapon_portalgun_player" + plr.entindex())
    local pViewmodel = Entities.FindByName(null, "predicted_viewmodel_player" + plr.entindex())

    if (pGun && pViewmodel) {
        EntFire("weapon_portalgun_player" + plr.entindex(), "SetBodygroup", charOnOff, 0)
        EntFire("predicted_viewmodel_player" + plr.entindex(), "SetBodyGroup", charOnOff, 0)
    }
}

function CanJump(enable = false, player = "all") {
    local name = "p2mmtemp_CanJump"
    local mainent = Entities.FindByName(null, name)
    if (!mainent) {
        mainent = Entities.CreateByClassname("player_speedmod")
        mainent.__KeyValueFromString("targetname", name)
    }

    mainent.__KeyValueFromString("spawnflags", "4")

    local set = "1.01"
    if (enable) { set = "1" }

    if (player == "all") {
        for (local p = null; p = Entities.FindByClassname(p, "player");) {
            EntFireByHandle(mainent, "modifyspeed", set, 0, p, p)
        }
    } else {
        EntFireByHandle(mainent, "modifyspeed", set, 0, player, player)
    }
}

function CanUse(enable = false, player = "all") {
    local name = "p2mmtemp_CanUse"
    local mainent = Entities.FindByName(null, name)
    if (!mainent) {
        mainent = Entities.CreateByClassname("player_speedmod")
        mainent.__KeyValueFromString("targetname", name)
    }

    mainent.__KeyValueFromString("spawnflags", "16")

    local set = "1.01"
    if (enable) { set = "1" }

    if (player == "all") {
        for (local p = null; p = Entities.FindByClassname(p, "player");) {
            EntFireByHandle(mainent, "modifyspeed", set, 0, p, p)
        }
    } else {
        EntFireByHandle(mainent, "modifyspeed", set, 0, player, player)
    }
}

function CanCrouch(enable = false, player = "all") {
    local name = "p2mmtemp_CanCrouch"
    local mainent = Entities.FindByName(null, name)
    if (!mainent) {
        mainent = Entities.CreateByClassname("player_speedmod")
        mainent.__KeyValueFromString("targetname", name)
    }

    mainent.__KeyValueFromString("spawnflags", "8")

    local set = "1.01"
    if (enable) { set = "1" }

    if (player == "all") {
        for (local p = null; p = Entities.FindByClassname(p, "player");) {
            EntFireByHandle(mainent, "modifyspeed", set, 0, p, p)
        }
    } else {
        EntFireByHandle(mainent, "modifyspeed", set, 0, player, player)
    }
}

function EnableHud(enable = false, player = "all") {
    local name = "p2mmtemp_EnableHud"
    local mainent = Entities.FindByName(null, name)
    if (!mainent) {
        mainent = Entities.CreateByClassname("player_speedmod")
        mainent.__KeyValueFromString("targetname", name)
    }

    mainent.__KeyValueFromString("spawnflags", "2")

    local set = "1.01"
    if (enable) { set = "1" }

    if (player == "all") {
        for (local p = null; p = Entities.FindByClassname(p, "player");) {
            EntFireByHandle(mainent, "modifyspeed", set, 0, p, p)
        }
    } else {
        EntFireByHandle(mainent, "modifyspeed", set, 0, player, player)
    }
}

function EnablePortalGun(enable = false, player = "all") {
    local set = "0"
    if (enable) { set = "1" }

    local draw = "disabledraw"
    if (enable) { draw = "enabledraw" }

    if (player = "all") {
        for (local p = null; p = Entities.FindByClassname(p, "player");) {
            local ent = Entities.FindByName(null, "weapon_portalgun_player" + p.entindex())
            local entviewmodel = Entities.FindByName(null, "predicted_viewmodel_player" + p.entindex())
            ent.__KeyValueFromString("CanFirePortal1", set)
            ent.__KeyValueFromString("CanFirePortal2", set)
            EntFire(ent, draw)
            EntFireByHandle(entviewmodel, draw, "", 0, null, null)
        }
    } else {
        local ent = Entities.FindByName(null, "weapon_portalgun_player" + player.entindex())
        local entviewmodel = Entities.FindByName(null, "predicted_viewmodel_player" + player.entindex())
        ent.__KeyValueFromString("CanFirePortal1", set)
        ent.__KeyValueFromString("CanFirePortal2", set)
        EntFire(ent, draw)
        EntFireByHandle(entviewmodel, draw, "", 0, null, null)
    }
}

function EnableSpectator(enable = true, player = "all") {
    local enable = !enable
    local draw = "DisableDraw"
    if (enable) { draw = "EnableDraw" }

    local fov = "100"
    if (enable) { fov = "90" }

    if (player == "all") {
        for (local p = null; p = Entities.FindByClassname(p, "player");) {
            CanCrouch(enable, p)
            CanJump(enable, p)
            CanUse(enable, p)
            EntFire(p, draw)
            EnableNoclip(!enable, p)
            EnablePortalGun(enable, p)
            SetSpeed(p, 1.2)
            EntFireByHandle(p2mm_clientcommand, "command", "cl_fov " + fov.tostring(), 0, p, p)
        }
    } else {
        CanCrouch(enable, player)
        CanJump(enable, player)
        CanUse(enable, player)
        EntFire(player, draw)
        EnableNoclip(!enable, player)
        EnablePortalGun(enable, player)
        SetSpeed(player, 1.2)
        EntFireByHandle(p2mm_clientcommand, "command", "cl_fov " + fov.tostring(), 0, player, player)
    }
}

function EnableNoclip(enable, player = "all") {
    if (player == "all") {
        for (local p = null; p = Entities.FindByClassname(p, "player");) {
            local currentplayerclass = FindPlayerClass(p)
            if (enable) {
                EntFireByHandle(p, "AddOutput", "MoveType 8", 0, null, null)
                currentplayerclass.noclip = true
            } else {
                EntFireByHandle(p, "AddOutput", "MoveType 2", 0, null, null)
                currentplayerclass.noclip = false
            }
        }
    } else {
        local currentplayerclass = FindPlayerClass(player)
        if (enable) {
            EntFireByHandle(player, "AddOutput", "MoveType 8", 0, null, null)
            currentplayerclass.noclip = true
        } else {
            EntFireByHandle(player, "AddOutput", "MoveType 2", 0, null, null)
            currentplayerclass.noclip = false
        }
    }
}

function SetSpeed(player, speed) {
    EntFireByHandle(Entities.FindByName(null, "p2mm_player_speedmod"), "modifyspeed", speed.tostring(), 0, player, player)
}

// Find the spawn point for the map // Returns a class with {red and blue} in each of those subclasses there is {spawnpoint and rotation}
function BestGuessSpawnpoint() {
    if (!MadeSpawnClass) {
        // Box ents
        local BoxEnts = [
            "@arrival_video_master",
            "@departure_video_master",
            "@end_of_playtest_text",
            "@debug_dump_map_bat_file",
            "@debug_change_to_next_map",
            "@chapter_subtitle_text",
            "@chapter_title_text",
            "@transition_script",
            "@transition_from_map",
        ]

        if (GetDeveloperLevelP2MM()) {
            printl("===========================")
            printlP2MM("Box ents")
            printl("===========================")
        }

        local BestSurrondingBoxEnt = -1
        local CurrentBestStartingEnt = null
        local StartingBoxEnt = null
        foreach (PossibleEnt in BoxEnts) {
            local PossibleSurroundingEnts = 0
            local CurrentBoi = Entities.FindByName(null, PossibleEnt)
            if (CurrentBoi) {
                // If we have found one yet lets tally up the amount of surronding box ents
                for (local ent = null; ent = Entities.FindInSphere(ent, CurrentBoi.GetOrigin(), 300);) {
                    foreach (TEnt in BoxEnts) {
                        if (ent.GetName() == TEnt) {
                            PossibleSurroundingEnts = PossibleSurroundingEnts + 1
                        }
                    }
                }
                // If this is the best one so far, save it
                if (PossibleSurroundingEnts > BestSurrondingBoxEnt) {
                    BestSurrondingBoxEnt = PossibleSurroundingEnts
                    StartingBoxEnt = CurrentBoi
                }
            }
        }

        local RealPlayerSpawn = null
        if (StartingBoxEnt == null) {
            if (GetDeveloperLevelP2MM()) {
                printlP2MM("No starting box ent found.")
            }
        } else {
            if (BestSurrondingBoxEnt > 0) {
                if (GetDeveloperLevelP2MM()) {
                    printlP2MM("Starting box ent found!")
                }
                // If we have found a solid starting box ent, lets find the closest one to it
                RealPlayerSpawn = Entities.FindByClassnameNearest("info_player_start", StartingBoxEnt.GetOrigin(), 650)
                if (RealPlayerSpawn == null) {
                    if (GetDeveloperLevelP2MM()) {
                        printlP2MM("No real player spawn found.")
                    }
                } else {
                    if (GetDeveloperLevelP2MM()) {
                        printlP2MM("Real player spawn found!")
                    }
                    local LandmarkCheck = Entities.FindByClassnameNearest("info_landmark_entry", RealPlayerSpawn.GetOrigin(), 128)
                    // If we have found a landmark, we know we are in the box
                    if (LandmarkCheck == null) {
                        if (GetDeveloperLevelP2MM()) {
                            printlP2MM("No landmark found")
                        }
                    } else {
                        if (GetDeveloperLevelP2MM()) {
                            printlP2MM("Landmark found!")
                            printlP2MM("Found info_player_start entity!: " + RealPlayerSpawn.GetOrigin())
                        }
                        // If EVERY Condition is met, lets set the player spawn
                        if (GlobalSpawnClass.m_bUseAutoSpawn) {
                            if (GetDeveloperLevelP2MM()) {
                                printlP2MM("m_bUseAutoSpawn = True: Setting player spawn")
                            }
                            GlobalSpawnClass.m_bUseAutoSpawn <- false
                            GlobalSpawnClass.m_bUseSetSpawn <- true
                            GlobalSpawnClass.m_cSetSpawn.position <- RealPlayerSpawn.GetOrigin()
                            GlobalSpawnClass.m_cSetSpawn.radius <- 200
                            // Get every info_player_start and kill it
                            for (local ent = null; ent = Entities.FindByClassname(ent, "info_player_start");) {
                                if (ent != RealPlayerSpawn) {
                                    if (GetDeveloperLevelP2MM()) {
                                        printlP2MM("Found info_player_start entity that is not the real player spawn.")
                                    }
                                    ent.Destroy()
                                }
                            }
                        } else {
                            if (GetDeveloperLevelP2MM()) {
                                printlP2MM("m_bUseAutoSpawn = false: Not setting player spawn.")
                            }
                        }
                    }
                }
            } else {
                if (GetDeveloperLevelP2MM()) {
                    printlP2MM("Starting box ent found, but there aren't enough surrounding box ents.")
                }
            }
        }
    }
    if (!MadeSpawnClass && GlobalSpawnClass.m_cBluePlayers.spawnpoint.x == 0 && GlobalSpawnClass.m_cBluePlayers.spawnpoint.y == 0) {

        // Setup some variables
        local ourclosest = 99999999
        local spawnmiddle = null
        local FinalSpawnRed = Vector(0, 0, 0)
        local FinalRotationRed = Vector(0, 0, 0)
        local FinalSpawnBlue = Vector(0, 0, 0)
        local FinalRotationBlue = Vector(0, 0, 0)

        // Singlepayer spawn stuff

        // New Aperture
        if (Entities.FindByModel(null, "models/elevator/elevator_tube_opener.mdl")) {
            for (local ent = null; ent = Entities.FindByModel(ent, "models/elevator/elevator_tube_opener.mdl");) {
                local elevator = Entities.FindByName(null, "arrival_elevator-elevator_1")
                // Get the nearest elevator
                local elevator_pos = elevator.GetOrigin()
                local ent_pos = ent.GetOrigin()

                local currentscore = elevator_pos - ent_pos
                currentscore = UnNegative(currentscore)
                if (GetDeveloperLevelP2MM()) {
                    printlP2MM(currentscore)
                }
                currentscore = currentscore.x + currentscore.y + currentscore.z
                if (currentscore < ourclosest) {
                    ourclosest = currentscore
                    spawnmiddle = ent
                }
            }

            // Find the angle of the spawnpoint in xyz using cos
            local spawnmiddle_ang_vec = Entities.FindByName(null, "@arrival_teleport").GetForwardVector()
            local spawnmiddle_ang = Entities.FindByName(null, "@arrival_teleport").GetAngles()
            local height = 180

            spawnmiddle_ang_vec = spawnmiddle_ang_vec * 126.5

            if (GetDeveloperLevelP2MM()) {
                printlP2MM(spawnmiddle_ang_vec)
            }

            // Now get the back front left and right spawnpoints
            local spawnfront = spawnmiddle.GetOrigin() + Vector(spawnmiddle_ang_vec.x, spawnmiddle_ang_vec.y, height)
            local spawnback = spawnmiddle.GetOrigin() + Vector(spawnmiddle_ang_vec.x/-1, spawnmiddle_ang_vec.y/-1, height)
            local spawnright = spawnmiddle.GetOrigin() + Vector(spawnmiddle_ang_vec.y, spawnmiddle_ang_vec.x/-1, height)
            local spawnleft = spawnmiddle.GetOrigin() + Vector(spawnmiddle_ang_vec.y/-1, spawnmiddle_ang_vec.x, height)
            if (GetDeveloperLevelP2MM()) {
                printlP2MM("spawnMiddle: " + spawnmiddle)
                printlP2MM("spawnOrigin: " + spawnmiddle.GetOrigin())
                printlP2MM("ourClosest: " + ourclosest)
            }

            // Output the spawnpoints
            FinalRotationBlue = spawnmiddle_ang + Vector(0, 0, 0)
            FinalSpawnBlue = spawnright
            FinalRotationRed = spawnmiddle_ang + Vector(0, 0, 0)
            FinalSpawnRed = spawnleft
        }

        // Old Aperture
        if (Entities.FindByModel(null, "models/props_underground/elevator_a.mdl")) {
            local elevator = Entities.FindByName(null, "@test_dome_lift_entry_teleport")
            local spawnmiddle = null
            // Find the nearst elevator to the point_teleport
            for (local ent = null; ent = Entities.FindByModel(ent, "models/props_underground/elevator_a.mdl");) {
                if (elevator == null) {
                    elevator = Entities.FindByClassname(null, "point_teleport")
                }
                // Get the nearest elevator to the point_teleport
                local elevator_pos = elevator.GetOrigin()
                local ent_pos = ent.GetOrigin()

                local currentscore = elevator_pos - ent_pos
                currentscore = UnNegative(currentscore)
                if (GetDeveloperLevelP2MM()) {
                    printlP2MM(currentscore)
                }
                currentscore = currentscore.x + currentscore.y + currentscore.z
                if (currentscore < ourclosest) {
                    ourclosest = currentscore
                    spawnmiddle = ent
                }
            }

            // Find the highest path_track next to the spawnpoint
            local tallestpathtrack = null
            if (spawnmiddle == null) {
                if (GetDeveloperLevelP2MM()) {
                    printlP2MM("Failed to find spawnmiddle for path_track spawnpoint!")
                }
            } else {
                for (local pathtracks = null; pathtracks = Entities.FindByClassnameWithin(pathtracks, "path_track", spawnmiddle.GetOrigin(), 600);) {
                    if (GetDeveloperLevelP2MM()) {
                        printlP2MM("pathtracks: " + pathtracks)
                    }
                    if (tallestpathtrack == null) {
                        tallestpathtrack = pathtracks
                    } else {
                        if (tallestpathtrack.GetOrigin().z < pathtracks.GetOrigin().z) {
                            tallestpathtrack = pathtracks
                        }
                    }
                }
            }

            local extrah = 5

            // Set the origin of the spawnpoint middle
            local spawnpointmiddle = Vector(spawnmiddle.GetOrigin().x, spawnmiddle.GetOrigin().y, tallestpathtrack.GetOrigin().z)
            local spawnpointmiddle_ang_vec = elevator.GetForwardVector()
            local spawnpointmiddle_ang = elevator.GetAngles()

            // Set the sides of the spawnpoint
            spawnpointmiddle_ang_vec = spawnpointmiddle_ang_vec *  100

            local spawnfront = spawnpointmiddle + Vector(spawnpointmiddle_ang_vec.x, spawnpointmiddle_ang_vec.y, extrah)
            local spawnback = spawnpointmiddle + Vector(spawnpointmiddle_ang_vec.x/-1, spawnpointmiddle_ang_vec.y/-1, extrah)
            local spawnright = spawnpointmiddle + Vector(spawnpointmiddle_ang_vec.y, spawnpointmiddle_ang_vec.x/-1, extrah)
            local spawnleft = spawnpointmiddle + Vector(spawnpointmiddle_ang_vec.y/-1, spawnpointmiddle_ang_vec.x, extrah)

            // Finalize the spawnpoints
            FinalRotationBlue = spawnpointmiddle_ang
            FinalSpawnBlue = spawnright
            FinalRotationRed = spawnpointmiddle_ang
            FinalSpawnRed = spawnleft

        }

        // Override parts of the global spawn class
        GlobalSpawnClass.m_cBluePlayers.spawnpoint <- FinalSpawnBlue
        GlobalSpawnClass.m_cBluePlayers.rotation <- FinalRotationBlue
        GlobalSpawnClass.m_cRedPlayers.spawnpoint <- FinalSpawnRed
        GlobalSpawnClass.m_cRedPlayers.rotation <- FinalRotationRed

        MadeSpawnClass = true
        return GlobalSpawnClass
    } else {
        MadeSpawnClass = true
        return GlobalSpawnClass
    }
}

function TeleportToSpawnPoint(p, SpawnClass) {
    if (SpawnClass == null) {
        SpawnClass = BestGuessSpawnpoint()
    }

    if (p.GetTeam() == TEAM_BLUE) {
        // Blue team
        p.SetOrigin(SpawnClass.m_cBluePlayers.spawnpoint)
        p.SetAngles(SpawnClass.m_cBluePlayers.rotation.x, SpawnClass.m_cBluePlayers.rotation.y, SpawnClass.m_cBluePlayers.rotation.z)
        p.SetVelocity(SpawnClass.m_cBluePlayers.velocity)
    }
    else if (p.GetTeam() == TEAM_RED) {
        // Red team
        p.SetOrigin(SpawnClass.m_cRedPlayers.spawnpoint)
        p.SetAngles(SpawnClass.m_cRedPlayers.rotation.x, SpawnClass.m_cRedPlayers.rotation.y, SpawnClass.m_cRedPlayers.rotation.z)
        p.SetVelocity(SpawnClass.m_cRedPlayers.velocity)
    }
    // If someone respawns after dying on the singleplayer team, they will automatically
    // be switched to the native team that they joined the server with
}

function CombineList(list, startlength, inbetweenchars = " ") {
    local indx = -1
    local newstr = ""
    foreach (thing in list) {
        indx = indx + 1
        if (indx >= startlength) {
            newstr = newstr + thing + inbetweenchars
        }
    }
    return strip(newstr)
}

function CreateOurEntities() {

    if (Config_UseNametags/* && g_bAllowNametags*/) {
        // Create an entity to measure player eye angles
        measuremovement <- Entities.CreateByClassname("logic_measure_movement")
        measuremovement.__KeyValueFromString( "measuretype", "1")
        measuremovement.__KeyValueFromString( "measurereference", "" )
        measuremovement.__KeyValueFromString( "measureretarget", "" )
        measuremovement.__KeyValueFromString( "targetscale", "1.0" )
        measuremovement.__KeyValueFromString( "targetname", "p2mm_logic_measure_movement" )
        measuremovement.__KeyValueFromString( "targetreference", "p2mm_logic_measure_movement" )
        measuremovement.__KeyValueFromString( "target", "p2mm_logic_measure_movement" )
        EntFireByHandle(measuremovement, "SetMeasureReference", "p2mm_logic_measure_movement", 0.0, null, null)
        EntFireByHandle(measuremovement, "Disable", "", 0.0, null, null)

        // Create an entity to display player nametags when aiming at them
        nametagdisplay <- Entities.CreateByClassname("game_text")
        nametagdisplay.__KeyValueFromString("targetname", "p2mm_nametag_text")
        nametagdisplay.__KeyValueFromString("x", "-1")
        nametagdisplay.__KeyValueFromString("y", "0.2")
        nametagdisplay.__KeyValueFromString("holdtime", "0.1")
        nametagdisplay.__KeyValueFromString("fadeout", "0.2")
        nametagdisplay.__KeyValueFromString("fadein", "0.2")
        nametagdisplay.__KeyValueFromString("channel", "1")
    }

    // Create an display entity for the host to wait for another player to load in
    onscreendisplay <- Entities.CreateByClassname("game_text")
    onscreendisplay.__KeyValueFromString("targetname", "p2mm_wait_for_players_text")
    onscreendisplay.__KeyValueFromString("message", "Waiting for players...")
    onscreendisplay.__KeyValueFromString("holdtime", "0.2")
    onscreendisplay.__KeyValueFromString("fadeout", "0")
    onscreendisplay.__KeyValueFromString("fadein", "0")
    onscreendisplay.__KeyValueFromString("spawnflags", "1")
    onscreendisplay.__KeyValueFromString("color", "50 190 50")
    onscreendisplay.__KeyValueFromString("channel", "1")

    // Create a player disconnect message entity
    local disconnectmessagedisplay = Entities.CreateByClassname("game_text")
    disconnectmessagedisplay.__KeyValueFromString("targetname", "p2mm_player_disconnect_message")
    disconnectmessagedisplay.__KeyValueFromString("holdtime", "3")
    disconnectmessagedisplay.__KeyValueFromString("fadeout", "0.2")
    disconnectmessagedisplay.__KeyValueFromString("fadein", "0.2")
    disconnectmessagedisplay.__KeyValueFromString("spawnflags", "1")
    disconnectmessagedisplay.__KeyValueFromString("color", "140 40 40")
    disconnectmessagedisplay.__KeyValueFromString("channel", "3")
    disconnectmessagedisplay.__KeyValueFromString("message", "Player disconnected")

    if (Config_UseJoinIndicator) {
        // Create a join message entity
        local joinmessagedisplay = Entities.CreateByClassname("game_text")
        joinmessagedisplay.__KeyValueFromString("targetname", "p2mm_player_joined_text")
        joinmessagedisplay.__KeyValueFromString("holdtime", "3")
        joinmessagedisplay.__KeyValueFromString("fadeout", "0.2")
        joinmessagedisplay.__KeyValueFromString("fadein", "0.2")
        joinmessagedisplay.__KeyValueFromString("spawnflags", "1")
        joinmessagedisplay.__KeyValueFromString("color", "255 200 0")
        joinmessagedisplay.__KeyValueFromString("channel", "3")
    }

    // Create a player_speedmod entity to modify a player's movement speed
    local playerspeedmod = Entities.CreateByClassname("player_speedmod")
    playerspeedmod.__KeyValueFromString("targetname", "p2mm_player_speedmod")

    // Create an entity that sends miscellaneous client commands
    p2mm_clientcommand <- Entities.CreateByClassname("point_clientcommand")
    p2mm_clientcommand.__KeyValueFromString("targetname", "p2mm_clientcommand") // Using the targetname in outputs causes invalid entity instance errors ??
}

function CalcNumPlayers() {
    local iCurrentNumPlayers = 0
    for (local player; player = Entities.FindByClassname(player, "player");) {
        iCurrentNumPlayers++
    }
    return iCurrentNumPlayers
}

// Function name is sensitive to the hex edits!
function Plyr_Disconnect_Function(displayname = null) {
    if (displayname == null) {
        displayname = "Player"
    }
        if (displayname == "\\n") {
        displayname = "\\\\n"
    }

    Entities.FindByName(null, "p2mm_player_disconnect_message").__KeyValueFromString("message", displayname + " disconnected (" + (CalcNumPlayers() - 1).tostring() + "/" + iMaxPlayers.tostring() + ")")
    EntFire("p2mm_player_disconnect_message", "Display")
}

//--------------------------------------
// Manage what each team can do
//--------------------------------------

for (local i = 1; i < 5; i++) {
    Entities.CreateByClassname("env_global").__KeyValueFromString("targetname", "p2mm_env_global0" + i.tostring())
}

Entities.FindByName(null, "p2mm_env_global01").__KeyValueFromString("globalstate", "no_pinging_blue")
Entities.FindByName(null, "p2mm_env_global02").__KeyValueFromString("globalstate", "no_pinging_orange")
Entities.FindByName(null, "p2mm_env_global03").__KeyValueFromString("globalstate", "no_taunting_blue")
Entities.FindByName(null, "p2mm_env_global04").__KeyValueFromString("globalstate", "no_taunting_orange")

class UTIL_Team {
    bPortalgunEnabled_Blue = true
    bPortalgunEnabled_Red = true
    // bTauntingEnabled_Blue = true
    // bTauntingEnabled_Red = true
    // bPingingEnabled_Blue = true
    // bPingingEnabled_Red = true

    constructor() {
        // Set default state for gun spawn
        if (Entities.FindByName(null, "supress_blue_portalgun_spawn")) {
            bPortalgunEnabled_Blue = false
        }
        if (Entities.FindByName(null, "supress_orange_portalgun_spawn")) {
            bPortalgunEnabled_Blue = false
        }

        // TODO: If we can find out how to read the default state of
        // pinging and taunting, then this code can be done a bit cleaner.
        // For now, accept all inputs to enable/disable these two.
    }
}

function UTIL_Team::Spawn_PortalGun(bEnableOrDisable, charBlueOrRed = "all") {
    if (bEnableOrDisable) {
        local DestroyAllTargets = function(team) {
            for (local target; target = Entities.FindByName(target, team);) {
                target.Destroy()
            }
        }
        if ((charBlueOrRed == "blue" || charBlueOrRed == "all") && !UTIL_Team.bPortalgunEnabled_Blue) {
            DestroyAllTargets("supress_blue_portalgun_spawn")
            UTIL_Team.bPortalgunEnabled_Blue = true
        }
        if ((charBlueOrRed == "red" || charBlueOrRed == "all") && !UTIL_Team.bPortalgunEnabled_Red) {
            DestroyAllTargets("supress_orange_portalgun_spawn")
            UTIL_Team.bPortalgunEnabled_Red = true
        }
        return
    }
    if ((charBlueOrRed == "blue" || charBlueOrRed == "all") && UTIL_Team.bPortalgunEnabled_Blue) {
        Entities.CreateByClassname("info_target").__KeyValueFromString("targetname", "supress_blue_portalgun_spawn")
        UTIL_Team.bPortalgunEnabled_Blue = false
    }
    if ((charBlueOrRed == "red" || charBlueOrRed == "all") && UTIL_Team.bPortalgunEnabled_Red) {
        Entities.CreateByClassname("info_target").__KeyValueFromString("targetname", "supress_orange_portalgun_spawn")
        UTIL_Team.bPortalgunEnabled_Red = false
    }
}

function UTIL_Team::Pinging(bEnableOrDisable, charBlueOrRed = "all", delay = 0) {
    if (bEnableOrDisable) {
        if ((charBlueOrRed == "blue" || charBlueOrRed == "all")/* && !UTIL_Team.bPingingEnabled_Blue*/) {
            EntFireByHandle(Entities.FindByName(null, "p2mm_env_global01"), "turnoff", "", delay, null, null)
            // UTIL_Team.bPingingEnabled_Blue = true
        }
        if ((charBlueOrRed == "red" || charBlueOrRed == "all")/* && !UTIL_Team.bPingingEnabled_Red*/) {
            EntFireByHandle(Entities.FindByName(null, "p2mm_env_global02"), "turnoff", "", delay, null, null)
            // UTIL_Team.bPingingEnabled_Red = true
        }
    } else {
        if ((charBlueOrRed == "blue" || charBlueOrRed == "all")/* && UTIL_Team.bPingingEnabled_Blue*/) {
            EntFireByHandle(Entities.FindByName(null, "p2mm_env_global01"), "turnon", "", delay, null, null)
            // UTIL_Team.bPingingEnabled_Blue = false
        }
        if ((charBlueOrRed == "red" || charBlueOrRed == "all")/* && UTIL_Team.bPingingEnabled_Red*/) {
            EntFireByHandle(Entities.FindByName(null, "p2mm_env_global02"), "turnon", "", delay, null, null)
            // UTIL_Team.bPingingEnabled_Red = false
        }
    }
}

function UTIL_Team::Taunting(bEnableOrDisable, charBlueOrRed = "all", delay = 0) {
    if (bEnableOrDisable) {
        if ((charBlueOrRed == "blue" || charBlueOrRed == "all")/* && !UTIL_Team.bTauntingEnabled_Blue*/) {
            EntFireByHandle(Entities.FindByName(null, "p2mm_env_global03"), "turnoff", "", delay, null, null)
            // UTIL_Team.bTauntingEnabled_Blue = true
        }
        if ((charBlueOrRed == "red" || charBlueOrRed == "all")/* && !UTIL_Team.bTauntingEnabled_Red*/) {
            EntFireByHandle(Entities.FindByName(null, "p2mm_env_global04"), "turnoff", "", delay, null, null)
            // UTIL_Team.bTauntingEnabled_Red = true
        }
    } else {
        if ((charBlueOrRed == "blue" || charBlueOrRed == "all")/* && UTIL_Team.bTauntingEnabled_Blue*/) {
            EntFireByHandle(Entities.FindByName(null, "p2mm_env_global03"), "turnon", "", delay, null, null)
            // UTIL_Team.bTauntingEnabled_Blue = false
        }
        if ((charBlueOrRed == "red" || charBlueOrRed == "all")/* && UTIL_Team.bTauntingEnabled_Red*/) {
            EntFireByHandle(Entities.FindByName(null, "p2mm_env_global04"), "turnon", "", delay, null, null)
            // UTIL_Team.bTauntingEnabled_Red = false
        }
    }
}

UTIL_Team <- UTIL_Team()

//--------------------------------------
// Data functions
//--------------------------------------

function GetType(var, simplify = true) {
    local type = typeof(var)

    if (!simplify) {
        return type
    } else {
        if (type == "float" || type == "integer") {
            return "number"
        } else if (type == "string") {
            return "string"
        } else if (type == "bool") {
            return "bool"
        } else if (type == "table" || type == "array") {
            return "table"
        } else if (type == "instance") {
            return "entity"
        } else if (type == "function") {
            return "function"
        } else {
            return "unknown"
        }
    }
}

//--------------------------------------
// Table functions
//--------------------------------------

function Join(tbl, str) {
    local nstr = ""
    foreach (thing in tbl) {
        nstr = nstr + thing + str
    }
    return nstr
}

//--------------------------------------
// String functions
//--------------------------------------

function Len(str) {
    return str.len()
}

function Find(str, substr) {
    return str.find(substr)
}

function Slice(str, start, end = null) {
    if (end == null) {
        end = Len(str)
    }
    try {
        str = str.slice(start, end)
    } catch (e) {
        str = ""
    }
    return str
}

function Contains(out, find = "") {
    local type = GetType(out)

    if (type == "null") {
        return false
    } else if (type == "number") {
        return true
    } else if (type == "string") {
        return Contains(Find(out, find))
    }
    return false
}

function Replace(str, find, replace) {
    if (find == replace) {
        return str
    }

    local findlen = Find(str, find)
    local len = Len(find)
    if (Contains(findlen)) {
        str = Slice(str, 0, findlen) + replace + Slice(str, findlen + len)
        if (Contains(str, find)) {
            str = Replace(str, find, replace)
        }
        return str
    } else {
        return str
    }
}

function StartsWith(str, substr) {
    str = Slice(str, 0, Len(substr))
    if (str == substr) {
        return true
    } else {
        return false
    }
}
