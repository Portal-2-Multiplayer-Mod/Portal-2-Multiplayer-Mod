//------------------------------------------------------------------------------------------------------------------------------------------------//
//                                                                   COPYRIGHT                                                                    //
//                                                        Â© 2022 Portal 2: Multiplayer Mod                                                        //
//                                      https://github.com/kyleraykbs/Portal2-32PlayerMod/blob/main/LICENSE                                       //
// In the case that this file does not exist at all or in the GitHub repository, this project will fall under a GNU LESSER GENERAL PUBLIC LICENSE //
//------------------------------------------------------------------------------------------------------------------------------------------------//

//---------------------------------------------------
//         *****!Do not edit this file!*****
//---------------------------------------------------
//   __  __
//  |  \/  |  __ _  _ __   ___  _ __    __ _ __      __ _ __   _
//  | |\/| | / _` || '_ \ / __|| '_ \  / _` |\ \ /\ / /| '_ \ (_)
//  | |  | || (_| || |_) |\__ \| |_) || (_| | \ V  V / | | | | _
//  |_|  |_| \__,_|| .__/ |___/| .__/  \__,_|  \_/\_/  |_| |_|(_)
//                 |_|         |_|
//---------------------------------------------------
// Purpose: The heart of the mod's content. Runs on
// every map transition to bring about features and
//                 fixes for 3+ MP.
//---------------------------------------------------

// TODO: Find out how to determine whether or not a
// session is dedicated or listen IN VSCRIPT

//-------------------------------------------------------------------------------------------
// This file is called on map transitions for both the client VM and server VM
// If the server type is a listen server, then this specific file would be called twice
// We differentiate between the two by whether or not the VM can control the entities
//-------------------------------------------------------------------------------------------

if (!("Entities" in this)/* || GetMapName().find(".bsp") != null || Time().tostring() != "1"*/) {
    printl("\n----------------------------------")
    printl("==== calling mapspawn.nut (CLIENT)")
    printl("----------------------------------\n")

    // If someone uses mapspawn.nut actively, they can put their code here

    return // Terminate execution
}

//-------------------------------------------------------------------------------------------

printl("\n----------------------------------")
printl("==== calling mapspawn.nut (SERVER)")
printl("----------------------------------\n")

if (Entities.FindByName(null, "p2mm_servercommand")) {
    printlP2MM("mapspawn.nut (SERVER) has already ran and is attempting to run again! Suppressing...")
    return
}

function printlP2MM(str) {
    printl("(P2:MM): " + str)
}

// Now we take care of some tasks first thing

printlP2MM("Session info...")
printlP2MM("- Current map: " + GetMapName())

// Determine what the "maxplayers" cap is
iMaxPlayers <- (Entities.FindByClassname(null, "team_manager").entindex() - 1)
printlP2MM("- Max players allowed on the server: " + iMaxPlayers)

// TODO: Determine whether or not this is a dedicated server
// Right now it needs to manually be assigned
// if (IsLocalSplitScreen()) {
    // if (Time() <= 1.63333) { // This is the latest known time a host client loads into a listen server

    // }
    IsDedicatedServer <- false
// } else {
//     IsDedicatedServer <- true
// }
printlP2MM("- Dedicated server: " + IsDedicatedServer + "\n")

IncludeScript("multiplayermod/pluginfunctionscheck.nut") // Make sure we know the exact status of our plugin
IncludeScript("multiplayermod/config.nut") // Import the user configuration and preferences
IncludeScript("multiplayermod/configcheck.nut") // Make sure nothing was invalid and compensate

// Create a global point_servercommand entity for us to pass through commands
// We don't want to create multiple when it is called on, so reference it by targetname
Entities.CreateByClassname("point_servercommand").__KeyValueFromString("targetname", "p2mm_servercommand")

if (GetDeveloperLevel() == 918612) {
    // Take care of anything pertaining to progress check and how our plugin did when loading
    IncludeScript("multiplayermod/firstmapload.nut")
    return
}

//-------------------------------------------------------------------------------------------

// Continue loading the P2:MM fixes, game mode, and features

IncludeScript("multiplayermod/variables.nut")
IncludeScript("multiplayermod/safeguard.nut")
IncludeScript("multiplayermod/functions.nut")
IncludeScript("multiplayermod/hooks.nut")
IncludeScript("multiplayermod/chatcommands.nut")

// Load the data system after everything else has been loaded
// IncludeScript("multiplayermod/datasystem/datasystem-main.nut") Commented out for now, still need to finish

// Always have global root functions imported for any level
IncludeScript("multiplayermod/mapsupport/#propcreation.nut")
IncludeScript("multiplayermod/mapsupport/#rootfunctions.nut")

//---------------------------------------------------

// Print P2:MM game art in console
foreach (line in ConsoleAscii) { printl(line) }
delete ConsoleAscii

//---------------------------------------------------

// Now, manage everything the player has set in config.nut
// If the gamemode has exceptions of any kind, it will revert to standard mapsupport

// Import map support code
// Map name will be wonky if the client VM attempts to get the map name
function LoadMapSupportCode(gametype) {
    printl("\n=============================================================")
    printlP2MM("Attempting to load " + gametype + " mapsupport code!")
    printl("=============================================================\n")

    if (gametype != "standard") {
        try {
            // Import the core functions before the actual mapsupport
            IncludeScript("multiplayermod/mapsupport/" + gametype + "/#" + gametype + "functions.nut")
        } catch (exception) {
            printlP2MM("Failed to load the " + gametype + " core functions file!")
        }
    }

    try {
        IncludeScript("multiplayermod/mapsupport/" + gametype + "/" + GetMapName() + ".nut")
    } catch (exception) {
        if (gametype == "standard") {
            printlP2MM("Failed to load standard mapsupport for " + GetMapName() + "\n")
        } else {
            printlP2MM("Failed to load " + gametype + " mapsupport code! Reverting to standard mapsupport...")
            return LoadMapSupportCode("standard")
        }
    }
}

// Now, manage everything the player has set in config.nut
// If the gamemode has exceptions of any kind, it will revert to standard mapsupport
switch (Config_GameMode) {
case 0:     LoadMapSupportCode("standard");     break
case 1:     LoadMapSupportCode("speedrun");     break
case 2:     LoadMapSupportCode("deathmatch");   break
case 3:     LoadMapSupportCode("futbol");       break
default:
    printlP2MM("\"Config_GameMode\" value in config.nut is invalid! Be sure it is set to an integer from 0-3. Reverting to standard mapsupport.")
    LoadMapSupportCode("standard"); break
}

//---------------------------------------------------

// Run InstantRun() shortly AFTER spawn (hooks.nut)

// Make sure that the user is in multiplayer mode before initiating everything
if (!IsMultiplayer()) {
    printlP2MM("This is not a multiplayer session! Disconnecting client...")
    EntFire("p2mm_servercommand", "command", "disconnect \"You cannot play the singleplayer mode when Portal 2 is launched from the Multiplayer Mod launcher. Please unmount and launch normally to play singleplayer.\"")
}

// InstantRun() must be delayed slightly
EntFire("p2mm_servercommand", "command", "script InstantRun()", 0.02)
