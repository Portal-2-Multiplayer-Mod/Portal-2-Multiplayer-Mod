//------------------------------------------------------------------------------------------------------------------------------------------------//
//                                                                   COPYRIGHT                                                                    //
//                                                        Â© 2022 Portal 2: Multiplayer Mod                                                        //
//                                      https://github.com/kyleraykbs/Portal2-32PlayerMod/blob/main/LICENSE                                       //
// In the case that this file does not exist at all or in the GitHub repository, this project will fall under a GNU LESSER GENERAL PUBLIC LICENSE //
//------------------------------------------------------------------------------------------------------------------------------------------------//

//---------------------------------------------------
//         *****!Do not edit this file!*****
//---------------------------------------------------
//   __  __
//  |  \/  |  __ _  _ __   ___  _ __    __ _ __      __ _ __   _
//  | |\/| | / _` || '_ \ / __|| '_ \  / _` |\ \ /\ / /| '_ \ (_)
//  | |  | || (_| || |_) |\__ \| |_) || (_| | \ V  V / | | | | _
//  |_|  |_| \__,_|| .__/ |___/| .__/  \__,_|  \_/\_/  |_| |_|(_)
//                 |_|         |_|
//---------------------------------------------------
// Purpose: The heart of the mod's content. Runs on
// every map transition to bring about features and
//                 fixes for 3+ MP.
//---------------------------------------------------

// mapspawn.nut is called twice on map transitions for some reason...
// Prevent the second run
if (!("Entities" in this)) {
    return
}

printl("\n-------------------------")
printl("==== calling mapspawn.nut")
printl("-------------------------\n")

// Make sure we know whether the plugin is loaded or not
// before including other files that depend on its value
IncludeScript("multiplayermod/pluginfunctionscheck.nut")

// Directly after including the user config, we need to make sure that
// nothing is invalid, and to take care of anything that is
IncludeScript("multiplayermod/config.nut")
IncludeScript("multiplayermod/configcheck.nut")

IncludeScript("multiplayermod/variables.nut")
IncludeScript("multiplayermod/safeguard.nut")
IncludeScript("multiplayermod/functions.nut")
IncludeScript("multiplayermod/loop.nut")
IncludeScript("multiplayermod/hooks.nut")
IncludeScript("multiplayermod/chatcommands.nut")

// Always have global root functions imported for any level
IncludeScript("multiplayermod/mapsupport/#propcreation.nut")
IncludeScript("multiplayermod/mapsupport/#rootfunctions.nut")

// Print P2:MM game art in console
foreach (line in ConsoleAscii) {
    printl(line)
}

//---------------------------------------------------

// First, manage everything the player has set in config.nut
// If the gamemode has exceptions of any kind, it will revert to standard mapsupport

// This is how we communicate with all mapsupport files. By default, no support is loaded
function MapSupport(MSInstantRun, MSLoop, MSPostPlayerSpawn, MSPostMapSpawn, MSOnPlayerJoin, MSOnDeath, MSOnRespawn) {}

// Import map support code
function LoadMapSupportCode(gametype) {
    printl("\n=============================================================")
    printl("(P2:MM): Attempting to load " + gametype + " mapsupport code!")
    printl("=============================================================\n")

    local MapName = FindAndReplace(GetMapName().tostring(), "maps/", "")
    MapName = FindAndReplace(MapName.tostring(), ".bsp", "")

    if (gametype != "standard") {
        try {
            // Import the core functions before the actual mapsupport
            IncludeScript("multiplayermod/mapsupport/" + gametype + "/#" + gametype + "functions.nut")
        } catch (exception) {
            printl("(P2:MM): Failed to load the " + gametype + " core functions file!")
        }
    }

    try {
        IncludeScript("multiplayermod/mapsupport/" + gametype + "/" + MapName.tostring() + ".nut")
    } catch (exception) {
        if (gametype == "standard") {
            printl("(P2:MM): Failed to load standard mapsupport for " + GetMapName() + "\n")
        } else {
            printl("(P2:MM): Failed to load " + gametype + " mapsupport code! Reverting to standard mapsupport...")
            return LoadMapSupportCode("standard")
        }
    }
}

try {
    switch (Config_GameMode) {
        case 0: LoadMapSupportCode("standard");     break;
        case 1: LoadMapSupportCode("speedrun");     break;
        case 2: LoadMapSupportCode("deathmatch");   break;
        case 3: LoadMapSupportCode("futbol");       break;
    }
} catch (exception) {
    printl("(P2:MM): \"Config_GameMode\" value in config.nut is invalid! Be sure it is set to an integer from 0-3. Reverting to standard mapsupport.")
    LoadMapSupportCode("standard")
}

//---------------------------------------------------

// Second, run init()

// init() will run on every map spawn or transition
// It does a few things:
// 1. Attempt to load our plugin if it has not been loaded
// 2. Trigger our map-specific code and loop the loop() function
// 3. Create map-specific entities after a delay

function init() {

    // Create a global point_servercommand entity for us to pass through commands
    p2mm_servercommand <- Entities.CreateByClassname("point_servercommand")
    p2mm_servercommand.__KeyValueFromString("targetname", "p2mm_servercommand")

    // Load plugin if it exists
    // Also change the level once it has succeeded this
    if (!PluginLoaded) {
        EntFire("p2mm_servercommand", "command", "clear", 0.03)

        printl("\n=========================================")
        printl("    P2:MM plugin has not been loaded!")
        printl("Some functionality will not be available!")
        printl("=========================================\n")

        EntFire("p2mm_servercommand", "command", "script printl(\"(P2:MM): Attempting to load the P2:MM plugin...\")", 0.03)
        EntFire("p2mm_servercommand", "command", "plugin_load 32pmod", 0.05)

        if (GetDeveloperLevel() == 918612) { // First load after game launch
            if (Config_DevMode) {
                EntFire("p2mm_servercommand", "command", "developer 1", 0.01)
            } else {
                EntFire("p2mm_servercommand", "command", "developer 0", 0.01)
            }
            // Must be delayed
            EntFire("p2mm_servercommand", "command", "script MakeProgressCheck()", 1)
        }
    }

    // Trigger mapsupport code
    MapSupport(true, false, false, false, false, false, false)

    // Create an entity to loop the loop() function
    p2mm_timer <- Entities.CreateByClassname("logic_timer")
    p2mm_timer.__KeyValueFromString("targetname", "p2mm_timer")
    EntFireByHandle(p2mm_timer, "AddOutput", "RefireTime " + TickSpeed, 0, null, null)
    EntFireByHandle(p2mm_timer, "AddOutput", "classname move_rope", 0, null, null)
    EntFireByHandle(p2mm_timer, "AddOutput", "OnTimer worldspawn:RunScriptCode:loop():0:-1", 0, null, null)
    EntFireByHandle(p2mm_timer, "Enable", "", looptime, null, null)

    // Delay the creation of our entities before so that we don't get an engine error from the entity limit
    EntFire("p2mm_servercommand", "command", "script CreateOurEntities()", 0.05)
}

function MakeProgressCheck() {
    for (local course = 1; course <= 6; course++) {
        // 9 levels is the highest that a course has
        for (local level = 1; level <= 9; level++) {
            if (IsLevelComplete(course - 1, level - 1)) {
                EntFire("p2mm_servercommand", "command", "changelevel mp_coop_lobby_3", 0)
                return
            }
        }
    }
    EntFire("p2mm_servercommand", "command", "changelevel mp_coop_start", 0)
}

//---------------------------------------------------

// Third, make init() run shortly AFTER spawn

try {
    MakeSPCheck() // Make sure that the user is in multiplayer mode before loading anything else
    DoEntFire("worldspawn", "FireUser1", "", 0.02, null, null) // init() must be delayed
    Entities.First().ConnectOutput("OnUser1", "init")
} catch (e) {
    printl("(P2:MM): Initializing our custom support!\n")
}