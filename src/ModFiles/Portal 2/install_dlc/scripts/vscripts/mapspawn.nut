//------------------------------------------------------------------------------------------------------------------------------------------------//
//                                                                   COPYRIGHT                                                                    //
//                                                        Â© 2022 Portal 2: Multiplayer Mod                                                        //
//                                      https://github.com/kyleraykbs/Portal2-32PlayerMod/blob/main/LICENSE                                       //
// In the case that this file does not exist at all or in the GitHub repository, this project will fall under a GNU LESSER GENERAL PUBLIC LICENSE //
//------------------------------------------------------------------------------------------------------------------------------------------------//

//---------------------------------------------------
//         *****!Do not edit this file!*****
//---------------------------------------------------

printl("\n-------------------------")
printl("==== calling mapspawn.nut")
printl("-------------------------\n")

// Make sure we know whether the plugin is loaded or not before including other files
if ("GetPlayerName" in this) {
    PluginLoaded <- true
} else {
    PluginLoaded <- false
}

IncludeScript("multiplayermod/config.nut")
IncludeScript("multiplayermod/variables.nut")
IncludeScript("multiplayermod/safeguard.nut")
IncludeScript("multiplayermod/functions.nut")
IncludeScript("multiplayermod/loop.nut")
IncludeScript("multiplayermod/hooks.nut")
IncludeScript("multiplayermod/chatcommands.nut")

// Always have global root functions imported for any level
IncludeScript("multiplayermod/mapsupport/#propcreation.nut")
IncludeScript("multiplayermod/mapsupport/#rootfunctions.nut")

// Print P2:MM game art in console
foreach (line in ConsoleAscii) {
    printl(line)
}

//---------------------------------------------------

// First, manage what gamemode we are running in
// If the gamemode has exceptions of any kind, it will revert to standard mapsupport

// This is how we communicate with all mapsupport files. By default, no support is loaded
function MapSupport(MSInstantRun, MSLoop, MSPostPlayerSpawn, MSPostMapSpawn, MSOnPlayerJoin, MSOnDeath, MSOnRespawn) {}

// Import map support code
function LoadMapSupportCode(gametype) {
    printl("\n=============================================================")
    printl("(P2:MM): Attempting to load " + gametype + " mapsupport code!")
    printl("=============================================================\n")
    
    local MapName = FindAndReplace(GetMapName().tostring(), "maps/", "")
    MapName = FindAndReplace(MapName.tostring(), ".bsp", "")

    try {
        try {
            // Import the core functions before the actual mapsupport
            if (gametype == "speedrun") {
                IncludeScript("multiplayermod/mapsupport/speedrun/#speedrunfunctions.nut")
            }
            if (gametype == "deathmatch") {
                IncludeScript("multiplayermod/mapsupport/deathmatch/#deathmatchfunctions.nut")
            }
            if (gametype == "futbol") {
                IncludeScript("multiplayermod/mapsupport/futbol/#futbolfunctions.nut")
            }
        } catch (exception) {
            printl("(P2:MM): Failed to load the " + gametype + " core functions file!")
        }
        IncludeScript("multiplayermod/mapsupport/" + gametype + "/" + MapName.tostring() + ".nut")
    } catch (exception) {
        if (gametype == "standard") {
            printl("(P2:MM): Failed to load standard mapsupport for " + GetMapName() + "\n")
        } else {
            printl("(P2:MM): Failed to load " + gametype + " mapsupport code! Reverting to standard mapsupport...")
            return LoadMapSupportCode("standard")
        }
    }
}

// Now, we load what mapsupport we need based on config.nut:
try {
    switch (GameMode) {
        case 0: LoadMapSupportCode("standard");     break;
        case 1: LoadMapSupportCode("speedrun");     break;
        case 2: LoadMapSupportCode("deathmatch");   break;
        case 3: LoadMapSupportCode("futbol");       break;
    }
} catch (exception) {
    printl("(P2:MM): \"GameMode\" value in config.nut is invalid! Be sure it is set to an integer from 0-3. Reverting to standard mapsupport.")
    LoadMapSupportCode("standard")
}

//---------------------------------------------------

// Second, run init()

// init() will run on every map spawn or transition
// It does a few things:
// 1. Attempt to load our plugin if it has not been loaded,
//    and compensate if it doesn't exist.
// 2. Trigger our map-specific code and loop the loop() function
// 3. Create map-specific entities after a delay

function init() {

    // Create a global point_servercommand entity for us to pass through commands
    p2mm_servercommand <- Entities.CreateByClassname("point_servercommand")
    p2mm_servercommand.__KeyValueFromString("targetname", "p2mm_servercommand")

    // Load plugin if it exists and compensate if it doesn't
    // Also change the level once it has succeeded this
    if (!PluginLoaded) {
        MakePluginReplacementFunctions()

        printl("\n=========================================")
        printl("    P2:MM plugin has not been loaded!")
        printl("Some functionality will not be available!")
        printl("=========================================\n")

        EntFire("p2mm_servercommand", "command", "clear", 0.03)
        EntFire("p2mm_servercommand", "command", "echo (P2:MM): Attempting to load the P2:MM plugin...", 0.03)
        EntFire("p2mm_servercommand", "command", "plugin_load 32pmod", 0.05)
        if (GetDeveloperLevel() == 918612) {
            if (DevMode) {
                EntFire("p2mm_servercommand", "command", "developer 1", 0.01)
            } else {
                EntFire("p2mm_servercommand", "command", "developer 0", 0.01)
            }
            printl("Resetting map so that the plugin has an effect! (in the hopes that it loaded)\n\n\n\n\n\n\n\n\n\n")
            EntFire("p2mm_servercommand", "command", "clear", 0)
            EntFire("p2mm_servercommand", "command", "changelevel " + GetMapName(), 0.2)
        }
    }

    // Trigger mapsupport code
    MapSupport(true, false, false, false, false, false, false)

    // Create an entity to run the loop() function every 0.1 second
    p2mm_timer <- Entities.CreateByClassname("logic_timer")
    p2mm_timer.__KeyValueFromString("targetname", "p2mm_timer")
    EntFireByHandle(p2mm_timer, "AddOutput", "RefireTime " + TickSpeed, 0, null, null)
    EntFireByHandle(p2mm_timer, "AddOutput", "classname move_rope", 0, null, null)
    EntFireByHandle(p2mm_timer, "AddOutput", "OnTimer worldspawn:RunScriptCode:loop():0:-1", 0, null, null)
    EntFireByHandle(p2mm_timer, "Enable", "", 0.1, null, null)

    // Delay the creation of our entities before so that we don't get an engine error from the entity limit
    EntFire("p2mm_servercommand", "command", "script CreateOurEntities()", 0.05)
}

//---------------------------------------------------

// Third, make init() run shortly AFTER spawn

try {
    MakeSPCheck() // Make sure that the user is in multiplayer mode before loading anything else
    DoEntFire("worldspawn", "FireUser1", "", 0.02, null, null) // init() must be delayed
    Entities.First().ConnectOutput("OnUser1", "init")
} catch(e) {
    printl("(P2:MM): Initializing our custom support!\n")
}